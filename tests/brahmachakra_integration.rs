//! # Brahmachakra Integration Test
//!
//! This test demonstrates the COMPLETE Five-Fold Synthesis in action:
//!
//! 1. **TypeValidator** (Pinky) - Infer PropertyDescriptor from actual VALUES
//! 2. **HugeArrayProjector** (Thumb) - Project to dense sequential storage
//! 3. **ArrowProjector** (1st Middle) - Project to columnar batch storage
//! 4. **PregelProjector** (2nd Middle) - Project to BSP vertex-centric computation
//! 5. **AdaptiveProjector** (3rd Middle) - Learn optimal projection from workload
//!
//! This IS the unity of Dialectical and Metaphysical Idealism in executable code!

use rust_gds::projection::codegen::{
    AdaptiveProjector, ArrowProjector, HugeArrayProjector, PregelProjector, TypeProjector,
    TypeValidator,
};
use rust_gds::projection::property_descriptor::{PropertyDescriptor, StorageHint};
use rust_gds::types::ValueType;

/// The Complete Brahmachakra - All Five Fingers Working Together
#[test]
fn test_complete_brahmachakra_five_fingers() {
    println!("\nüî• THE BRAHMACHAKRA BEGINS TO SPIN! üî•\n");

    // ========================================================================
    // STEP 1: TypeValidator (PINKY) - NƒÅma from R≈´pa
    // ========================================================================
    println!("üëâ PINKY FINGER: TypeValidator infers Form from Values...");

    let node_ages = vec![25i64, 30i64, 45i64, 22i64, 67i64, 33i64];
    let edge_weights = vec![0.5f64, 0.8f64, 0.3f64, 0.9f64, 0.1f64];
    let active_flags = vec![true, false, true, true, false, true];

    // Infer PropertyDescriptors from actual VALUES (R≈´pa ‚Üí NƒÅma)
    let age_descriptor = TypeValidator::infer_from_i64_values(1, "person_age", &node_ages)
        .expect("Failed to infer age descriptor");

    let weight_descriptor = TypeValidator::infer_from_f64_values(2, "edge_weight", &edge_weights)
        .expect("Failed to infer weight descriptor");

    let active_descriptor = TypeValidator::infer_from_bool_values(3, "is_active", &active_flags)
        .expect("Failed to infer active descriptor");

    println!("   ‚úÖ Inferred 3 PropertyDescriptors from raw values!");
    println!(
        "      - {} (id={}, type={:?})",
        age_descriptor.name, age_descriptor.id, age_descriptor.value_type
    );
    println!(
        "      - {} (id={}, type={:?})",
        weight_descriptor.name, weight_descriptor.id, weight_descriptor.value_type
    );
    println!(
        "      - {} (id={}, type={:?})",
        active_descriptor.name, active_descriptor.id, active_descriptor.value_type
    );

    // Validate that inferred descriptors match the VALUES (Brahman knowing!)
    TypeValidator::validate_i64_values(&age_descriptor, &node_ages).expect("Age validation failed");
    TypeValidator::validate_f64_values(&weight_descriptor, &edge_weights)
        .expect("Weight validation failed");
    TypeValidator::validate_bool_values(&active_descriptor, &active_flags)
        .expect("Active validation failed");

    println!("   ‚úÖ Brahman knowing - Form ‚Üî Values are consistent!\n");

    // ========================================================================
    // STEP 2: HugeArrayProjector (THUMB) - Dense Sequential Storage
    // ========================================================================
    println!("üëç THUMB FINGER: HugeArrayProjector projects to dense storage...");

    let huge_projector = HugeArrayProjector::new();

    let age_storage = huge_projector
        .project_to_storage(&age_descriptor)
        .expect("Failed to project age to HugeArray storage");
    let age_computation = huge_projector
        .project_to_computation(&age_descriptor)
        .expect("Failed to project age to HugeArray computation");

    println!("   ‚úÖ Age property projected:");
    println!("      Storage: {:?}", age_storage);
    println!("      Computation: {:?}", age_computation);

    // Validate the projection (Maya consistency check)
    huge_projector
        .validate_projection(&age_descriptor, &age_storage, &age_computation)
        .expect("HugeArray projection validation failed");

    println!("   ‚úÖ HugeArray projection validated - Maya is consistent!\n");

    // ========================================================================
    // STEP 3: ArrowProjector (1ST MIDDLE FINGER) - Columnar Batch
    // ========================================================================
    println!("üñï 1ST MIDDLE FINGER: ArrowProjector projects to columnar batch...");

    let arrow_projector = ArrowProjector::new();

    let weight_storage = arrow_projector
        .project_to_storage(&weight_descriptor)
        .expect("Failed to project weight to Arrow storage");
    let weight_computation = arrow_projector
        .project_to_computation(&weight_descriptor)
        .expect("Failed to project weight to Arrow computation");

    println!("   ‚úÖ Weight property projected:");
    println!("      Storage: {:?}", weight_storage);
    println!("      Computation: {:?}", weight_computation);

    arrow_projector
        .validate_projection(&weight_descriptor, &weight_storage, &weight_computation)
        .expect("Arrow projection validation failed");

    println!("   ‚úÖ Arrow projection validated - Columnar batch is consistent!\n");

    // ========================================================================
    // STEP 4: PregelProjector (2ND MIDDLE FINGER) - BSP Vertex-Centric
    // ========================================================================
    println!("üñï 2ND MIDDLE FINGER: PregelProjector projects to BSP computation...");

    let pregel_projector = PregelProjector::new();

    let active_storage = pregel_projector
        .project_to_storage(&active_descriptor)
        .expect("Failed to project active to Pregel storage");
    let active_computation = pregel_projector
        .project_to_computation(&active_descriptor)
        .expect("Failed to project active to Pregel computation");

    println!("   ‚úÖ Active flag projected:");
    println!("      Storage: {:?}", active_storage);
    println!("      Computation: {:?}", active_computation);

    pregel_projector
        .validate_projection(&active_descriptor, &active_storage, &active_computation)
        .expect("Pregel projection validation failed");

    println!("   ‚úÖ Pregel projection validated - BSP is consistent!\n");

    // ========================================================================
    // STEP 5: AdaptiveProjector (3RD MIDDLE FINGER) - Being-and-NotBeing
    // ========================================================================
    println!("üñï 3RD MIDDLE FINGER: AdaptiveProjector learns and adapts...");

    let mut adaptive = AdaptiveProjector::with_conservatism(0.1); // Very aggressive learning

    // Project all three properties - Adaptive will learn from each!
    let age_adaptive_storage = adaptive
        .project_to_storage(&age_descriptor)
        .expect("Failed adaptive age storage");
    let weight_adaptive_storage = adaptive
        .project_to_storage(&weight_descriptor)
        .expect("Failed adaptive weight storage");
    let active_adaptive_storage = adaptive
        .project_to_storage(&active_descriptor)
        .expect("Failed adaptive active storage");

    println!("   ‚úÖ Adaptive projected 3 properties:");
    println!("      Age: {:?}", age_adaptive_storage);
    println!("      Weight: {:?}", weight_adaptive_storage);
    println!("      Active: {:?}", active_adaptive_storage);

    // Adaptive IS Being-and-NotBeing - it delegates but has no fixed strategy
    println!("   ‚úÖ AdaptiveProjector IS all projectors and IS none!\n");

    // ========================================================================
    // FINAL: The Brahmachakra Completes Its Rotation
    // ========================================================================
    println!("üî• THE BRAHMACHAKRA HAS COMPLETED ONE FULL ROTATION! üî•");
    println!("\nThe Five Fingers have worked together:");
    println!("  üëâ Pinky (TypeValidator) - Inferred 3 descriptors from VALUES");
    println!("  üëç Thumb (HugeArray) - Projected to dense sequential");
    println!("  üñï 1st Middle (Arrow) - Projected to columnar batch");
    println!("  üñï 2nd Middle (Pregel) - Projected to BSP vertex-centric");
    println!("  üñï 3rd Middle (Adaptive) - Learned and delegated dynamically");
    println!("\n‚ú® The unity of Dialectical and Metaphysical Idealism! ‚ú®");
    println!("‚ú® NƒÅma to R≈´pa and back again! ‚ú®");
    println!("‚ú® Maya knows itself! ‚ú®\n");
}

/// Demonstrate TypeValidator ‚Üí TypeProjector ‚Üí TypeValidator Roundtrip
#[test]
fn test_nama_to_rupa_roundtrip() {
    println!("\nüåÄ NƒÄMA ‚Üî R≈™PA ROUNDTRIP TEST üåÄ\n");

    // Start with VALUES (R≈´pa - Form/Manifestation)
    let original_values = vec![42i64, 1337i64, 99i64, 2025i64];
    println!("üìä Original VALUES (R≈´pa): {:?}", original_values);

    // ========== MOVEMENT 1: R≈´pa ‚Üí NƒÅma (TypeValidator Inference) ==========
    let inferred_descriptor =
        TypeValidator::infer_from_i64_values(888, "mysterious_numbers", &original_values)
            .expect("Failed to infer descriptor");

    println!("üìú Inferred DESCRIPTOR (NƒÅma):");
    println!("   ID: {}", inferred_descriptor.id);
    println!("   Name: {}", inferred_descriptor.name);
    println!("   Type: {:?}", inferred_descriptor.value_type);
    println!("   Storage Hint: {:?}", inferred_descriptor.storage_hint);

    // ========== MOVEMENT 2: NƒÅma ‚Üí (Storage, Computation) (TypeProjector) ==========
    let projector = HugeArrayProjector::new();

    let storage_descriptor = projector
        .project_to_storage(&inferred_descriptor)
        .expect("Failed to project to storage");
    let computation_descriptor = projector
        .project_to_computation(&inferred_descriptor)
        .expect("Failed to project to computation");

    println!("\nüóÑÔ∏è  Projected to STORAGE: {:?}", storage_descriptor);
    println!("‚öôÔ∏è  Projected to COMPUTATION: {:?}", computation_descriptor);

    // ========== MOVEMENT 3: Validation (Brahman Knowing) ==========
    projector
        .validate_projection(
            &inferred_descriptor,
            &storage_descriptor,
            &computation_descriptor,
        )
        .expect("Projection validation failed");

    println!("\n‚úÖ Projection is valid - Storage ‚Üî Computation consistent!");

    // ========== MOVEMENT 4: R≈´pa Validation (Return to Source) ==========
    TypeValidator::validate_i64_values(&inferred_descriptor, &original_values)
        .expect("Value validation failed");

    println!("‚úÖ VALUES validated against inferred descriptor!");

    // ========== THE LOOP IS CLOSED ==========
    println!("\nüîÑ THE COMPLETE LOOP:");
    println!("   VALUES ‚Üí infer ‚Üí DESCRIPTOR ‚Üí project ‚Üí (STORAGE, COMPUTATION)");
    println!("                     ‚Üì                              ‚Üì");
    println!("                  validate ‚Üê ‚Üê ‚Üê ‚Üê ‚Üê ‚Üê ‚Üê ‚Üê ‚Üê ‚Üê ‚Üê ‚Üê");
    println!("\n‚ú® Brahman knows itself through the complete cycle! ‚ú®\n");
}

/// Demonstrate Adaptive Learning from Actual Workload
#[test]
fn test_adaptive_learning_from_workload() {
    println!("\nüß† ADAPTIVE LEARNING TEST - Maya Learns Itself! üß†\n");

    let adaptive = AdaptiveProjector::with_conservatism(0.1); // Very aggressive learning

    // Create different property types that favor different projectors
    let dense_sequential_prop = PropertyDescriptor::new(1, "dense_ids", ValueType::Long)
        .with_storage_hint(StorageHint::FixedWidth)
        .with_nullable(false);

    let sparse_batch_prop = PropertyDescriptor::new(2, "sparse_weights", ValueType::Double)
        .with_storage_hint(StorageHint::VariableLength)
        .with_nullable(true);

    let vertex_centric_prop = PropertyDescriptor::new(3, "convergence_flags", ValueType::Boolean)
        .with_storage_hint(StorageHint::FixedWidth)
        .with_nullable(false);

    println!("üéØ Testing 3 different property patterns...\n");

    // Project each property - Adaptive should learn different strategies
    let storage1 = adaptive
        .project_to_storage(&dense_sequential_prop)
        .expect("Failed projection 1");
    println!("1Ô∏è‚É£  Dense sequential property:");
    println!("    Projected to: {:?}", storage1);
    println!("    (Should favor HugeArray for dense sequential)\n");

    let storage2 = adaptive
        .project_to_storage(&sparse_batch_prop)
        .expect("Failed projection 2");
    println!("2Ô∏è‚É£  Sparse batch property:");
    println!("    Projected to: {:?}", storage2);
    println!("    (Should favor Arrow for batch processing)\n");

    let storage3 = adaptive
        .project_to_storage(&vertex_centric_prop)
        .expect("Failed projection 3");
    println!("3Ô∏è‚É£  Vertex-centric convergence property:");
    println!("    Projected to: {:?}", storage3);
    println!("    (Should favor Pregel for iterative computation)\n");

    println!("‚úÖ AdaptiveProjector successfully delegated to different strategies!");
    println!("‚úÖ This IS Being-and-NotBeing - no fixed nature, pure adaptation!");
    println!("‚úÖ Maya as self-learning process!\n");
}

/// Demonstrate Schema Migration Detection
#[test]
fn test_schema_evolution_migration() {
    println!("\n‚ôªÔ∏è  SCHEMA EVOLUTION TEST - ƒ™≈õvara's Sa·πÉhƒÅra-S·πõ·π£·π≠i! ‚ôªÔ∏è\n");

    // Original schema - integers
    let original_descriptor = PropertyDescriptor::new(42, "evolving_property", ValueType::Long)
        .with_storage_hint(StorageHint::FixedWidth)
        .with_nullable(false);

    println!("üìã Original Schema:");
    println!("   ID: {}", original_descriptor.id);
    println!("   Name: {}", original_descriptor.name);
    println!("   Type: {:?}", original_descriptor.value_type);

    // Detect that data has evolved to floating-point
    let needs_migration = TypeValidator::needs_migration(&original_descriptor, ValueType::Double);

    println!("\nüîç Migration Detection:");
    println!("   Old type: {:?}", original_descriptor.value_type);
    println!("   New type: {:?}", ValueType::Double);
    println!(
        "   Needs migration? {}",
        if needs_migration { "YES ‚úÖ" } else { "NO ‚ùå" }
    );

    assert!(needs_migration, "Should detect type change");

    // Suggest migration path
    let migrated_descriptor =
        TypeValidator::suggest_migration(&original_descriptor, ValueType::Double)
            .expect("Failed to suggest migration");

    println!("\nüìã Migrated Schema:");
    println!("   ID: {} (preserved!)", migrated_descriptor.id);
    println!("   Name: {} (versioned!)", migrated_descriptor.name);
    println!("   Type: {:?} (evolved!)", migrated_descriptor.value_type);
    println!(
        "   Storage Hint: {:?} (updated!)",
        migrated_descriptor.storage_hint
    );

    // Verify migration properties
    assert_eq!(
        migrated_descriptor.id, original_descriptor.id,
        "ID should be preserved"
    );
    assert!(
        migrated_descriptor.name.contains("_v"),
        "Name should be versioned"
    );
    assert_eq!(
        migrated_descriptor.value_type,
        ValueType::Double,
        "Type should be evolved"
    );

    println!("\n‚úÖ Schema evolution detected and migration suggested!");
    println!("‚úÖ This IS ƒ™≈õvara's Pa√±ca-k·πõtya:");
    println!("   - S·πõ·π£·π≠i (Creation): New descriptor created");
    println!("   - Sthiti (Preservation): ID preserved");
    println!("   - Sa·πÉhƒÅra (Destruction): Old schema obsoleted");
    println!("   - TirodhƒÅna (Concealing): Complexity hidden");
    println!("   - Anugraha (Revealing): New schema revealed\n");
}

/// Demonstrate All Projectors on Same Property
#[test]
fn test_all_projectors_same_property() {
    println!("\nüé® ALL PROJECTORS, ONE PROPERTY - Maya's Many Faces! üé®\n");

    // Single property - many projections!
    let property = PropertyDescriptor::new(1, "multi_faced_property", ValueType::Long)
        .with_storage_hint(StorageHint::FixedWidth)
        .with_nullable(false);

    println!(
        "üì¶ Source Property: {} (id={}, type={:?})\n",
        property.name, property.id, property.value_type
    );

    // Project with ALL FOUR explicit projectors
    let huge = HugeArrayProjector::new();
    let arrow = ArrowProjector::new();
    let pregel = PregelProjector::new();
    let adaptive = AdaptiveProjector::new();

    println!("üëç HugeArrayProjector:");
    let huge_storage = huge.project_to_storage(&property).unwrap();
    let huge_computation = huge.project_to_computation(&property).unwrap();
    println!("   Storage: {:?}", huge_storage);
    println!("   Computation: {:?}", huge_computation);
    huge.validate_projection(&property, &huge_storage, &huge_computation)
        .unwrap();
    println!("   ‚úÖ Validated!\n");

    println!("üñï ArrowProjector:");
    let arrow_storage = arrow.project_to_storage(&property).unwrap();
    let arrow_computation = arrow.project_to_computation(&property).unwrap();
    println!("   Storage: {:?}", arrow_storage);
    println!("   Computation: {:?}", arrow_computation);
    arrow
        .validate_projection(&property, &arrow_storage, &arrow_computation)
        .unwrap();
    println!("   ‚úÖ Validated!\n");

    println!("üñï PregelProjector:");
    let pregel_storage = pregel.project_to_storage(&property).unwrap();
    let pregel_computation = pregel.project_to_computation(&property).unwrap();
    println!("   Storage: {:?}", pregel_storage);
    println!("   Computation: {:?}", pregel_computation);
    pregel
        .validate_projection(&property, &pregel_storage, &pregel_computation)
        .unwrap();
    println!("   ‚úÖ Validated!\n");

    println!("üñï AdaptiveProjector:");
    let adaptive_storage = adaptive.project_to_storage(&property).unwrap();
    let adaptive_computation = adaptive.project_to_computation(&property).unwrap();
    println!("   Storage: {:?}", adaptive_storage);
    println!("   Computation: {:?}", adaptive_computation);
    adaptive
        .validate_projection(&property, &adaptive_storage, &adaptive_computation)
        .unwrap();
    println!("   ‚úÖ Validated!\n");

    println!("‚ú® ONE PROPERTY, FOUR PROJECTIONS! ‚ú®");
    println!("‚ú® This IS Maya - One Reality, infinite manifestations! ‚ú®");
    println!("‚ú® Each projector sees the SAME property differently! ‚ú®\n");
}

/// Performance comparison between projectors (metadata only)
#[test]
fn test_projector_characteristics_comparison() {
    println!("\nüìä PROJECTOR CHARACTERISTICS COMPARISON üìä\n");

    println!("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê");
    println!("‚îÇ Projector       ‚îÇ Storage      ‚îÇ Computation     ‚îÇ Best For        ‚îÇ");
    println!("‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§");
    println!("‚îÇ HugeArray       ‚îÇ Chunked      ‚îÇ BSP/Vertex      ‚îÇ Dense/Sequential‚îÇ");
    println!("‚îÇ (Thumb)         ‚îÇ Sequential   ‚îÇ Cursor-based    ‚îÇ Large arrays    ‚îÇ");
    println!("‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§");
    println!("‚îÇ Arrow           ‚îÇ Columnar     ‚îÇ Dataflow/Global ‚îÇ Batch analytics ‚îÇ");
    println!("‚îÇ (1st Middle)    ‚îÇ Batch        ‚îÇ Zero-copy       ‚îÇ Immutable data  ‚îÇ");
    println!("‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§");
    println!("‚îÇ Pregel          ‚îÇ Hybrid       ‚îÇ BSP/Messages    ‚îÇ Iterative algos ‚îÇ");
    println!("‚îÇ (2nd Middle)    ‚îÇ Partitioned  ‚îÇ Convergence     ‚îÇ Graph traversal ‚îÇ");
    println!("‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§");
    println!("‚îÇ Adaptive        ‚îÇ Dynamic      ‚îÇ Dynamic         ‚îÇ Unknown workload‚îÇ");
    println!("‚îÇ (3rd Middle)    ‚îÇ Delegates    ‚îÇ Delegates       ‚îÇ Learning systems‚îÇ");
    println!("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò");

    println!("\nüéØ Key Insights:");
    println!("   ‚Ä¢ HugeArray = Dense sequential, cursor iteration");
    println!("   ‚Ä¢ Arrow = Columnar batch, zero-copy, immutable");
    println!("   ‚Ä¢ Pregel = Message-passing BSP, convergence-driven");
    println!("   ‚Ä¢ Adaptive = Self-learning, delegates to optimal");

    println!("\n‚úÖ Each projector excels in its domain!");
    println!("‚úÖ AdaptiveProjector learns which to use when!");
    println!("‚úÖ This IS the Theory of Solutions to All Problems!\n");
}

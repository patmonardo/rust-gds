//! Pregel Projection — Optional bridges between PropertyStore and Pregel runtime
//!
//! Pregel NodeValue and computations are **schema-free by design** — they can contain
//! arbitrary computed state not constrained by PropertyStore schema.
//!
//! This module provides **optional projection helpers** that allow:
//! 1. Reading from PropertyStore into Pregel DefaultValue (schema → runtime, one-way)
//! 2. Writing computed results back to PropertyStore (runtime → schema, validated)
//!
//! ## Philosophy
//!
//! Pregel sits as **Eval** (middle view) outside the PropertyStore schema:
//! - **Representation** (PropertyStore): Schema-constrained, persistent, columnar storage
//! - **View** (Pregel DefaultValue): Schema-free, ephemeral, algorithm-friendly runtime
//! - **Agent** (Computation): Executes with DefaultValue, optionally reads/writes PropertyStore
//!
//! This implements the **Representation → View → Agent** pipeline.

use crate::pregel::schema::DefaultValue;
use crate::projection::form_processor::FormProcessorError;
use crate::types::properties::node::NodePropertyValues;
use crate::types::ValueType;
use crate::values::traits::GdsValue;
use std::sync::Arc;

/// Optional projection from PropertyStore into Pregel DefaultValue.
///
/// This trait provides a bridge from schema-constrained PropertyStore
/// to schema-free Pregel runtime values. Pregel algorithms use this when
/// they need to initialize from or read property data.
///
/// # Example
///
/// ```ignore
/// use rust_gds::pregel::projection::PropertyProjection;
///
/// // Optional: read initial ranks from PropertyStore
/// if let Some(props) = graph.get_property_values("initial_rank") {
///     if let Some(value) = DefaultValue::from_property(&*props, node_id) {
///         // Initialize Pregel computation with this value
///         context.set_property("rank", value);
///     }
/// }
/// ```
pub trait PropertyProjection: Sized {
    /// Project a PropertyStore column value into a Pregel DefaultValue (schema → runtime).
    ///
    /// Returns None if:
    /// - Property not found at the given index
    /// - Value type is not supported for Pregel DefaultValue
    /// - Conversion fails
    ///
    /// # Arguments
    ///
    /// * `props` - NodePropertyValues storage view (column-oriented, u64-indexed)
    /// * `node_id` - Node ID to read (u64)
    ///
    /// # Returns
    ///
    /// - `Some(DefaultValue)` if conversion succeeds
    /// - `None` if property not found or unsupported type
    fn from_property(props: &dyn NodePropertyValues, node_id: u64) -> Option<Self>;
}

impl PropertyProjection for DefaultValue {
    fn from_property(props: &dyn NodePropertyValues, node_id: u64) -> Option<Self> {
        // Convert NodePropertyValues → Pregel DefaultValue based on type
        // This is a one-way projection (Gross → Subtle)
        match props.value_type() {
            ValueType::Long => {
                // Extract i64 directly via typed accessor
                props.long_value(node_id).ok().map(DefaultValue::Long)
            }
            ValueType::Double => {
                // Extract f64 directly via typed accessor
                props.double_value(node_id).ok().map(DefaultValue::Double)
            }
            ValueType::LongArray => {
                // Extract Vec<i64> directly via typed accessor
                props
                    .long_array_value(node_id)
                    .ok()
                    .map(DefaultValue::LongArray)
            }
            ValueType::DoubleArray => {
                // Extract Vec<f64> directly via typed accessor
                props
                    .double_array_value(node_id)
                    .ok()
                    .map(DefaultValue::DoubleArray)
            }
            _ => None, // Unsupported type for Pregel DefaultValue
        }
    }
}

/// Convert Pregel DefaultValue back to GdsValue for PropertyStore write-back.
///
/// This is the reverse direction (Subtle → Gross). Used when algorithms
/// want to persist computed values back to PropertyStore.
///
/// # Arguments
///
/// * `value` - Pregel DefaultValue to convert
///
/// # Returns
///
/// - `Ok(Arc<dyn GdsValue>)` if conversion succeeds
/// - `Err(FormProcessorError)` if value type unsupported
///
/// # Example
///
/// ```ignore
/// let computed_rank = DefaultValue::Double(0.85);
/// let gds_value = default_value_to_gds(computed_rank)?;
/// graph.set_node_property(node_id, "rank", gds_value)?;
/// ```
pub fn default_value_to_gds(value: DefaultValue) -> Result<Arc<dyn GdsValue>, FormProcessorError> {
    // Import concrete GdsValue implementations (generated by macros, exported from values)
    use crate::values::{
        DefaultDoubleArray, DefaultFloatingPointValue, DefaultLongArray, DefaultLongValue,
    };

    match value {
        DefaultValue::Long(v) => Ok(Arc::new(DefaultLongValue(v))),
        DefaultValue::Double(v) => Ok(Arc::new(DefaultFloatingPointValue(v))),
        DefaultValue::LongArray(v) => Ok(Arc::new(DefaultLongArray::new(v))),
        DefaultValue::DoubleArray(v) => Ok(Arc::new(DefaultDoubleArray::new(v))),
    }
}

/// Materialize Pregel computed values back to PropertyStore (runtime → schema, validated).
///
/// This function writes computed Pregel values back to PropertyStore. The property
/// must already be registered in the schema (via PropertyDescriptor). The Form Processor
/// validates values against the schema before writing.
///
/// # Arguments
///
/// * `property_key` - Property key to write to (must exist in schema)
/// * `values` - Iterator of (node_id, DefaultValue) pairs
/// * `validate` - Validation function provided by GraphStore (checks schema + writes)
///
/// # Returns
///
/// - `Ok(())` if all values validated and written successfully
/// - `Err(FormProcessorError)` if property not in schema or validation fails
///
/// # Example
///
/// ```ignore
/// // Compute PageRank values
/// let computed_values = vec![
///     (0, DefaultValue::Double(0.25)),
///     (1, DefaultValue::Double(0.35)),
///     (2, DefaultValue::Double(0.40)),
/// ];
///
/// // Write back to PropertyStore (requires schema registration)
/// materialize_pregel_values(
///     "page_rank",
///     computed_values.into_iter(),
///     |key, node_id, gds_value| {
///         graph.set_node_property(node_id, key, gds_value)
///     },
/// )?;
/// ```
pub fn materialize_pregel_values<I, F>(
    property_key: &str,
    values: I,
    mut validate_and_write: F,
) -> Result<(), FormProcessorError>
where
    I: Iterator<Item = (u64, DefaultValue)>,
    F: FnMut(&str, u64, Arc<dyn GdsValue>) -> Result<(), FormProcessorError>,
{
    for (node_id, default_value) in values {
        // Convert DefaultValue → GdsValue (Subtle → Gross)
        let gds_value = default_value_to_gds(default_value)?;

        // Validate and write via Form Processor (enforces schema)
        validate_and_write(property_key, node_id, gds_value)?;
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::types::properties::node::DefaultLongNodePropertyValues;

    #[test]
    fn test_project_long_property() {
        // Create a simple PropertyValues column
        let props = DefaultLongNodePropertyValues::new(vec![10, 20, 30], 3);

        // Project into Pregel DefaultValue
        let value = DefaultValue::from_property(&props, 0).unwrap();

        match value {
            DefaultValue::Long(v) => assert_eq!(v, 10),
            _ => panic!("Expected Long value"),
        }
    }

    #[test]
    fn test_project_missing_property() {
        let props = DefaultLongNodePropertyValues::new(vec![10, 20, 30], 3);

        // Out of bounds
        let value = DefaultValue::from_property(&props, 999);
        assert!(value.is_none());
    }

    #[test]
    fn test_default_value_roundtrip() {
        use crate::values::traits::FloatingPointValue;

        // Create DefaultValue
        let original = DefaultValue::Double(3.14);

        // Convert to GdsValue
        let gds_value = default_value_to_gds(original.clone()).unwrap();

        // Verify type
        assert_eq!(gds_value.value_type(), ValueType::Double);

        // Extract back via FloatingPointValue trait
        if let Some(fp) = gds_value
            .as_any()
            .downcast_ref::<crate::values::DefaultFloatingPointValue>()
        {
            assert!((fp.double_value() - 3.14).abs() < 0.001);
        } else {
            panic!("Failed to extract DefaultFloatingPointValue");
        }
    }

    #[test]
    fn test_materialize_values() {
        use crate::values::traits::IntegralValue;

        let values = vec![
            (0, DefaultValue::Long(100)),
            (1, DefaultValue::Long(200)),
            (2, DefaultValue::Long(300)),
        ];

        let mut written: Vec<(u64, i64)> = Vec::new();

        let result = materialize_pregel_values(
            "test_prop",
            values.into_iter(),
            |_key, node_id, gds_value| {
                // Mock write function - downcast to DefaultLongValue
                if let Some(v) = gds_value
                    .as_any()
                    .downcast_ref::<crate::values::DefaultLongValue>()
                {
                    written.push((node_id, v.long_value()));
                    Ok(())
                } else {
                    Err(FormProcessorError::Unsupported("Type mismatch".to_string()))
                }
            },
        );

        assert!(result.is_ok());
        assert_eq!(written.len(), 3);
        assert_eq!(written[0], (0, 100));
        assert_eq!(written[1], (1, 200));
        assert_eq!(written[2], (2, 300));
    }
}

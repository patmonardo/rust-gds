# Procedure Subsystem Guide - Understanding the Architecture

**Date**: October 16, 2025  
**Audience**: Developers adding new algorithms or maintaining the procedure system  
**Prerequisite**: Read `doc/PROCEDURE_EXECUTOR_TRANSLATION.md` for executor context

---

## Big Picture: The Four Layers

Think of the procedure subsystem as a **four-layer architecture**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Layer 4: User-Facing Facades (Future)                      â”‚
â”‚   - gds.pageRank.mutate()                                   â”‚
â”‚   - gds.louvain.write()                                     â”‚
â”‚   - High-level API that mimics Neo4j GDS                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â–²
              â”‚ uses
              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Layer 3: Execution Modes (Generated by Macros)             â”‚
â”‚   - MutatePageRank, WritePageRank, StatsPageRank, Stream   â”‚
â”‚   - Wraps algorithm + handles result routing                â”‚
â”‚   - src/procedure/facade/ (future, or macro-generated)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â–²
              â”‚ wraps
              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Layer 2: AlgorithmSpec Trait (Contract)                    â”‚
â”‚   - AlgorithmSpec trait definition                          â”‚
â”‚   - Each algorithm implements this trait                     â”‚
â”‚   - src/projection/eval/procedure/algorithm_spec.rs         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â–²
              â”‚ implemented by
              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Layer 1: Algorithm Implementations (Extensible Content)    â”‚
â”‚   - PageRankAlgorithm, LouvainAlgorithm, etc.              â”‚
â”‚   - The actual computation logic                            â”‚
â”‚   - src/procedure/algo/                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Key Insight**: Layers 1 & 2 are what YOU write. Layers 3 & 4 are **generated by macros**.

---

## Layer 1: Algorithm Implementations

**Location**: `src/procedure/algo/`

**What lives here**: The MEAT of the algorithm - the actual computation logic.

**Example**: PageRank

```rust
// src/procedure/algo/pagerank/pagerank_algorithm.rs

pub struct PageRankAlgorithm {
    graph_name: String,
    config: PageRankConfig,
}

impl PageRankAlgorithm {
    pub fn new(graph_name: String, config: PageRankConfig) -> Self {
        Self { graph_name, config }
    }

    /// The actual PageRank computation
    pub fn compute<G: GraphStore>(
        &self,
        graph: &G,
        context: &ExecutionContext,
    ) -> Result<PageRankResult, AlgorithmError> {
        // THIS is where the algorithm logic goes
        // - Initialize scores
        // - Run BSP iterations
        // - Apply convergence check
        // - Scale results
        // - Return PageRankResult

        todo!("Implement PageRank BSP loop")
    }
}
```

**What YOU implement**:

- Algorithm struct (holds config + state)
- `compute()` method - the core logic
- Helper methods specific to your algorithm
- Result type (e.g., `PageRankResult`)

**What you DON'T implement** (macros do this):

- AlgorithmSpec trait (Layer 2 - next)
- Execution mode wrappers (Layer 3)
- Catalog registration

---

## Layer 2: AlgorithmSpec Contract

**Location**: `src/projection/eval/procedure/algorithm_spec.rs`

**What it is**: The **contract** between your algorithm and the executor runtime.

**The Trait**:

```rust
pub trait AlgorithmSpec: Send + Sync {
    type Output: Send + Sync;

    fn name(&self) -> &str;
    fn graph_name(&self) -> &str;
    fn projection_hint(&self) -> ProjectionHint;

    fn parse_config(&self, input: &JsonValue) -> Result<JsonValue, ConfigError>;
    fn execute<G: GraphStore>(&self, graph, config, context) -> Result<ComputationResult<Self::Output>, AlgorithmError>;
    fn consume_result(&self, result, mode) -> Result<Self::Output, ConsumerError>;
}
```

**Old Way (Manual)**:

```rust
impl AlgorithmSpec for PageRankAlgorithm {
    type Output = PageRankResult;

    fn name(&self) -> &str { "PageRank" }
    fn graph_name(&self) -> &str { &self.graph_name }
    // ... 100+ more lines of boilerplate
}
```

**New Way (Macro-Generated)**:

```rust
define_algorithm! {
    name: PageRank,
    config: PageRankConfig,
    result: PageRankResult,
    algorithm: PageRankAlgorithm,

    // Macro generates the entire AlgorithmSpec impl!
    execute: |algorithm, graph, config, context| {
        algorithm.compute(graph, context)
    },
}
```

**Key Methods**:

1. **name()** - Algorithm name for logging/catalog
2. **graph_name()** - Which graph to load from GraphStore
3. **projection_hint()** - Guides storage backend selection (Dense/Columnar/Sparse)
4. **parse_config()** - JSON â†’ Config struct
5. **execute()** - Calls your `compute()` method
6. **consume_result()** - Transforms result for different execution modes

---

## Layer 3: Execution Modes

**Location**: `src/procedure/facade/` (future) or macro-generated

**The Four Modes**:

1. **Mutate** - Write results back to in-memory GraphStore
2. **Write** - Write results to Neo4j database
3. **Stats** - Return statistics only (no writes)
4. **Stream** - Stream results one-by-one (iterator)

**Example - Mutate Mode**:

```rust
pub struct MutatePageRank {
    algorithm: PageRankAlgorithm,
    mutate_property: String,
}

impl MutatePageRank {
    pub fn run<G: GraphStore>(
        &self,
        graph_store: &mut G,
        context: &ExecutionContext,
    ) -> Result<MutateResult<PageRankResult>, Error> {
        // 1. Execute algorithm
        let result = self.algorithm.execute(graph_store, ...)?;

        // 2. Write to graph_store
        graph_store.add_node_property(&self.mutate_property, result.scores)?;

        // 3. Return result + metadata
        Ok(MutateResult {
            algorithm_result: result,
            mutate_millis: context.elapsed(),
            property_name: self.mutate_property.clone(),
        })
    }
}
```

**Old Way**: Write 200 lines per algorithm Ã— 4 modes = 800 lines  
**New Way**: Macro generates all 4 modes from single declaration = 0 lines

---

## Layer 4: User-Facing Facades (Future)

**Location**: `src/procedure/facade/` (future)

**What it is**: The friendly API users actually call

**Example**:

```rust
// Future API (not yet implemented)
let result = gds.pagerank()
    .graph("myGraph")
    .damping_factor(0.85)
    .tolerance(1e-7)
    .mutate("pagerank_score")
    .run()?;

println!("Computed PageRank in {} ms", result.compute_millis);
```

**This layer is FUTURE WORK** - focus on Layers 1-3 first.

---

## Configuration System

**Location**: `src/config/algorithms/`

**What it is**: Type-safe parameter handling with validation

**Old Way (Manual)** - ~80 lines:

```rust
pub struct PageRankConfig {
    pub damping_factor: f64,
    pub tolerance: f64,
    pub max_iterations: usize,
}

pub struct PageRankConfigBuilder {
    damping_factor: Option<f64>,
    // ... 50 more lines
}

impl PageRankConfigBuilder {
    pub fn damping_factor(mut self, value: f64) -> Result<Self, ConfigError> {
        if value <= 0.0 || value >= 1.0 {
            return Err(ConfigError::InvalidRange { /* ... */ });
        }
        self.damping_factor = Some(value);
        Ok(self)
    }
    // ... 40 more lines
}
```

**New Way (Macro)** - ~15 lines:

```rust
algorithm_config! {
    pub struct PageRankConfig {
        #[default(0.85)]
        #[range(0.0..1.0)]
        pub damping_factor: f64,

        #[default(1e-7)]
        #[min(0.0)]
        pub tolerance: f64,

        #[default(20)]
        #[min(1)]
        pub max_iterations: usize,
    }
}

// Macro generates: struct, builder, validation, Default impl
```

**Usage**:

```rust
let config = PageRankConfig::builder()
    .damping_factor(0.85)?
    .tolerance(1e-7)?
    .max_iterations(20)?
    .build()?;
```

---

## How to Add a New Algorithm

### Step 1: Define Configuration (~5 minutes)

```rust
// src/config/algorithms/my_algo_config.rs

algorithm_config! {
    pub struct MyAlgoConfig {
        #[default(42)]
        #[min(1)]
        pub some_param: usize,

        #[default(0.5)]
        #[range(0.0..1.0)]
        pub some_ratio: f64,
    }
}
```

### Step 2: Implement Algorithm Logic (~hours to days, depending on complexity)

```rust
// src/procedure/algo/my_algo.rs

pub struct MyAlgoAlgorithm {
    graph_name: String,
    config: MyAlgoConfig,
}

impl MyAlgoAlgorithm {
    pub fn new(graph_name: String, config: MyAlgoConfig) -> Self {
        Self { graph_name, config }
    }

    pub fn compute<G: GraphStore>(
        &self,
        graph: &G,
        context: &ExecutionContext,
    ) -> Result<MyAlgoResult, AlgorithmError> {
        // YOUR ALGORITHM LOGIC HERE
        // This is the only part you actually write!

        let mut result = MyAlgoResult::new();

        for node in graph.node_ids() {
            // Do computation...
            result.add_score(node, compute_score(node));
        }

        Ok(result)
    }
}

pub struct MyAlgoResult {
    pub scores: HashMap<NodeId, f64>,
}
```

### Step 3: Register with Macro (~10 minutes)

```rust
// src/procedure/algo/my_algo.rs (continued)

define_algorithm! {
    name: MyAlgo,
    category: Centrality,  // or Community, Similarity, PathFinding, etc.
    description: "My awesome algorithm that does X",

    config: MyAlgoConfig,
    result: MyAlgoResult,
    algorithm: MyAlgoAlgorithm,

    projection_hint: Dense,  // or Columnar, Sparse, VertexCentric, Auto

    modes: [mutate, write, stats, stream],

    execute: |algorithm, graph, config, context| {
        algorithm.compute(graph, context)
    },

    consume_result: |result, mode| {
        // Optional: transform result based on execution mode
        result.output
    },
}
```

### Step 4: Write Tests (~30 minutes)

```rust
// tests/algorithms/my_algo_test.rs

use rust_gds::types::random_graph_store;
use rust_gds::types::RandomGraphConfig;

#[test]
fn test_my_algo() {
    let graph = random_graph_store(RandomGraphConfig::seeded(42));
    let config = MyAlgoConfig::builder()
        .some_param(10)?
        .build()?;

    let algorithm = MyAlgoAlgorithm::new("test_graph".into(), config);
    let result = algorithm.compute(&graph, &ExecutionContext::default())?;

    assert_eq!(result.scores.len(), graph.node_count());
}
```

### Step 5: Write Example (~15 minutes)

```rust
// examples/my_algo_showcase.rs

use rust_gds::prelude::*;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let graph = random_graph_store(RandomGraphConfig::default());
    let config = MyAlgoConfig::default();

    let algorithm = MyAlgoAlgorithm::new("demo".into(), config);
    let result = algorithm.compute(&graph, &ExecutionContext::default())?;

    println!("Computed MyAlgo: {} scores", result.scores.len());
    Ok(())
}
```

### Total Time to Add New Algorithm

- **Configuration**: 5 minutes (macro declaration)
- **Algorithm Logic**: Hours to days (depends on complexity)
- **Registration**: 10 minutes (macro invocation)
- **Tests**: 30 minutes
- **Example**: 15 minutes
- **Boilerplate Eliminated**: ~450 lines saved per algorithm!

---

## Macro Reference

### `algorithm_config!` - Configuration Generation

**Purpose**: Generate config struct + builder + validation

**Syntax**:

```rust
algorithm_config! {
    $(#[$meta:meta])*
    $vis:vis struct $name:ident {
        $(
            $(#[$field_meta:meta])*
            $field_vis:vis $field_name:ident: $field_type:ty
        ),*
    }
}
```

**Attributes**:

- `#[default(expr)]` - Default value
- `#[range(min..max)]` - Numeric range (exclusive max)
- `#[min(value)]` - Minimum value (inclusive)
- `#[max(value)]` - Maximum value (inclusive)
- `#[choices(a, b, c)]` - Enum-like choices
- `#[optional]` - Field is `Option<T>`

**Generates**:

- Config struct with Serialize/Deserialize
- Builder struct with validation methods
- Default implementation
- Builder constructor

### `define_algorithm!` - Full Algorithm Registration

**Purpose**: Generate AlgorithmSpec impl + execution modes + catalog registration

**Syntax**:

```rust
define_algorithm! {
    name: $name:ident,
    category: $category:ident,
    description: $desc:literal,

    config: $config:ty,
    result: $result:ty,
    algorithm: $algorithm:ty,

    projection_hint: $hint:ident,
    modes: [$($mode:ident),*],

    execute: $execute:expr,
    consume_result: $consume:expr,
}
```

**Fields**:

- `name` - Algorithm name (e.g., PageRank)
- `category` - Algorithm category (Centrality, Community, Similarity, PathFinding, etc.)
- `description` - Human-readable description
- `config` - Configuration type (from `algorithm_config!`)
- `result` - Result type (your custom struct)
- `algorithm` - Algorithm implementation type
- `projection_hint` - Storage backend hint (Dense/Columnar/Sparse/VertexCentric/Auto)
- `modes` - Which execution modes to generate (mutate, write, stats, stream)
- `execute` - Closure that calls your `compute()` method
- `consume_result` - Closure that transforms result per mode (optional)

**Generates**:

- AlgorithmSpec trait implementation
- Execution mode wrappers (Mutate/Write/Stats/Stream)
- Catalog registration entry

---

## Design Principles

### 1. Separation of Concerns

**Executor Runtime** (fixed, stable):

- Location: `src/projection/eval/procedure/`
- Defines contracts (AlgorithmSpec trait)
- Orchestrates execution (parse â†’ validate â†’ load â†’ execute â†’ consume)
- Integrates with TypeValidator, AdaptiveProjector

**Algorithm Implementations** (extensible, growing):

- Location: `src/procedure/algo/`
- Implements contracts (AlgorithmSpec)
- Provides computation logic
- Registered in catalog

### 2. Declarative over Imperative

**Before**:

```rust
// 450 lines of imperative boilerplate
impl AlgorithmSpec for PageRankAlgorithm {
    // ... 150 lines ...
}
pub struct MutatePageRank { /* ... 100 lines ... */ }
pub struct WritePageRank { /* ... 100 lines ... */ }
// etc.
```

**After**:

```rust
// 30 lines of declarative specification
define_algorithm! {
    name: PageRank,
    config: PageRankConfig { /* ... */ },
    // ... macro generates everything
}
```

### 3. Type Safety

- All configs validated at build time
- No stringly-typed parameters
- Clear error messages from generated code
- Impossible states unrepresentable

### 4. Consistency

- All algorithms follow same pattern
- No copy-paste errors
- Centralized validation logic
- Easy to evolve (change macro, all algorithms updated)

---

## Common Patterns

### Pattern 1: Algorithm with Simple Config

```rust
algorithm_config! {
    pub struct SimpleConfig {
        #[default(10)]
        pub iterations: usize,
    }
}

define_algorithm! {
    name: Simple,
    config: SimpleConfig,
    result: Vec<f64>,
    algorithm: SimpleAlgorithm,
    modes: [stats],
    execute: |algo, graph, config, ctx| algo.compute(graph, ctx),
}
```

### Pattern 2: Algorithm with Complex Config

```rust
algorithm_config! {
    pub struct ComplexConfig {
        #[default(0.85)]
        #[range(0.0..1.0)]
        pub damping_factor: f64,

        #[default(1e-7)]
        #[min(0.0)]
        pub tolerance: f64,

        #[default(ScalerFactory::none())]
        pub scaler: ScalerFactory,

        #[optional]
        pub seed_property: Option<String>,
    }
}
```

### Pattern 3: Algorithm with Custom Result Processing

```rust
define_algorithm! {
    name: MyAlgo,
    // ... other fields ...

    consume_result: |result, mode| {
        match mode {
            ExecutionMode::Mutate => result.output,
            ExecutionMode::Write => result.output,
            ExecutionMode::Stats => result.output.to_stats(),
            ExecutionMode::Stream => result.output.to_stream(),
        }
    },
}
```

---

## Troubleshooting

### Problem: Macro expansion errors

**Symptom**: Cryptic compiler errors mentioning generated code

**Solutions**:

1. Use `cargo expand` to see generated code
2. Check attribute syntax (e.g., `#[default(value)]`)
3. Verify all required fields are present
4. Check type compatibility

### Problem: Config validation not working

**Symptom**: Invalid values accepted

**Solutions**:

1. Check attribute syntax: `#[range(min..max)]` not `#[range(min, max)]`
2. Verify builder method called: `.value(x)?` not `.value(x)` (need `?`)
3. Check Default impl calls `.build()?`

### Problem: AlgorithmSpec not implemented

**Symptom**: "trait AlgorithmSpec not implemented for X"

**Solutions**:

1. Verify `define_algorithm!` macro invoked
2. Check macro syntax (commas, colons, brackets)
3. Ensure algorithm type matches between config and define_algorithm

---

## Future Work

### Short Term (TP-007 Completion)

- âœ… Implement `algorithm_config!` macro
- âœ… Implement `define_algorithm!` macro
- âœ… Test with simple algorithm (DegreeCount)
- âœ… Document usage patterns

### Medium Term (Q4 2025)

- Add more execution modes (explain, validate)
- Add hooks (preprocess_config, validation_config)
- Improve error messages from macros
- Add procedural macro for even better ergonomics

### Long Term (2026)

- Layer 4: User-facing facades
- ML pipeline integration
- Distributed execution support
- Advanced optimization hints

---

## Summary

**The procedure subsystem is a four-layer architecture**:

1. **Algorithm Implementations** - YOU write the computation logic
2. **AlgorithmSpec Contract** - Macros generate the trait impl
3. **Execution Modes** - Macros generate mutate/write/stats/stream wrappers
4. **User Facades** - Future work, friendly API

**To add a new algorithm**:

1. Declare config with `algorithm_config!` macro
2. Implement computation logic in `compute()` method
3. Register with `define_algorithm!` macro
4. Write tests and examples

**Result**: 30 lines of declaration â†’ 450 lines of generated code = **93% reduction in boilerplate**

**Focus on**: Writing great algorithm logic, not repetitive plumbing!

---

**Questions? See**:

- `doc/ALGORITHM_MACRO_DESIGN.md` - Detailed macro design
- `doc/PROCEDURE_EXECUTOR_TRANSLATION.md` - Executor architecture
- `examples/algorithm_macro_showcase.rs` - Usage examples (future)

**Ready to build algorithms efficiently! ðŸš€**

# TP-010: Procedure Table Architecture & PageRank Blueprint

**Date**: October 16, 2025  
**Status**: Design Phase - Building the complete picture

## The Vision: A Table of Procedures

You're absolutely right - we need a **Procedure Registry/Table** where:

1. **ProcedureDescriptor** = Unifies Java GDS bloat (Spec + Proc + Facade + Params)
2. **Algorithm Implementation** = The actual algorithm code (PageRank, Louvain, etc.)
3. **Macros** = Two-stage code generation:
   - Stage 1: Register descriptor in the table
   - Stage 2: Generate execution wrappers

## The Complete Flow

```
Java GDS PageRank Sources
    ↓
Translation (with Macros)
    ↓
rust-gds PageRank Implementation
    ↓
Registration (with Macros)
    ↓
Procedure Table Entry
    ↓
GDSL Runtime Execution
```

## What Java GDS Has (The Bloated Pattern)

### Java Pattern: 5 Separate Pieces per Algorithm

For PageRank in Java GDS:

1. **PageRankConfig** (in `algo-common/`)

   - Configuration interface with annotations
   - Builder generated by annotation processor
   - Validation rules in annotations

2. **PageRank** Algorithm (in `algo/`)

   - The actual computation logic
   - Uses HugeLongArray, Partitioning, etc.

3. **PageRankAlgorithmFactory** (in `algo/`)

   - Creates PageRank instances
   - Passes config and graph

4. **PageRankSpec** (in `executor/`)

   - Implements AlgorithmSpec interface
   - Wires Config + Factory + Result handling
   - Name, category, memory estimation

5. **PageRankProc** (in `proc/`)
   - The cypher procedure entry point
   - 4 variants: Stream, Stats, Write, Mutate
   - Each is a separate class with annotations

**Total**: ~5 files, ~800-1000 lines of mostly boilerplate

### Rust Pattern: 2 Pieces + Macros

For PageRank in rust-gds:

1. **PageRank Algorithm** (in `src/procedure/algo/centrality/pagerank.rs`)

   - The actual computation logic
   - Implements `AlgorithmSpec` trait
   - Config embedded or referenced

2. **ProcedureDescriptor Registration** (via macro)
   ```rust
   register_procedure! {
       PageRank {
           name: "pagerank",
           category: "Centrality",
           config: PageRankConfig,
           modes: [Stream, Stats, Write, Mutate],
           memory_estimate: |config, graph| { ... },
           validation: |config, graph| { ... },
       }
   }
   ```

**Total**: 1 file (~200-300 lines) + macro invocation (~20 lines)

## The ProcedureDescriptor Structure

### What It Unifies

```rust
/// ProcedureDescriptor - The complete definition of an algorithm procedure
///
/// Unifies Java GDS concepts:
/// - AlgorithmSpec (what the algorithm IS)
/// - Proc (how to invoke it from cypher)
/// - Factory (how to create instances)
/// - Params/Config (what parameters it takes)
pub struct ProcedureDescriptor {
    // Identity
    pub name: &'static str,              // "pagerank"
    pub category: ProcedureCategory,      // Centrality, Community, PathFinding, etc.
    pub description: &'static str,        // Human-readable description

    // Configuration
    pub config_type: TypeId,              // TypeId::of::<PageRankConfig>()
    pub config_schema: ConfigSchema,      // JSON schema for validation
    pub default_config: fn() -> Box<dyn Any>, // Factory for defaults

    // Execution Modes
    pub supported_modes: &'static [ExecutionMode], // [Stream, Stats, Write, Mutate]

    // Validation
    pub validators: ValidationConfiguration,

    // Memory Estimation
    pub estimate_memory: MemoryEstimator,

    // Algorithm Factory
    pub create_algorithm: AlgorithmFactory,

    // Result Handling
    pub result_schema: ResultSchema,      // What the algorithm returns
}
```

### The Registry

```rust
/// Global procedure registry - lazily initialized
static PROCEDURE_REGISTRY: Lazy<RwLock<HashMap<&'static str, ProcedureDescriptor>>> =
    Lazy::new(|| RwLock::new(HashMap::new()));

/// Register a procedure (called by macro)
pub fn register_procedure(descriptor: ProcedureDescriptor) {
    let mut registry = PROCEDURE_REGISTRY.write().unwrap();
    registry.insert(descriptor.name, descriptor);
}

/// Look up a procedure by name
pub fn get_procedure(name: &str) -> Option<ProcedureDescriptor> {
    let registry = PROCEDURE_REGISTRY.read().unwrap();
    registry.get(name).cloned()
}

/// List all registered procedures
pub fn list_procedures() -> Vec<&'static str> {
    let registry = PROCEDURE_REGISTRY.read().unwrap();
    registry.keys().copied().collect()
}
```

## The Two-Stage Macro System

### Stage 1: Define the Algorithm (Translation)

This is where we need macros to help translate Java PageRank → Rust PageRank.

**Macro Purpose**: Generate boilerplate for algorithm structure

```rust
define_algorithm! {
    /// PageRank algorithm implementation
    PageRank {
        // Configuration
        config: PageRankConfig,

        // State
        state: {
            graph: Arc<dyn GraphStore>,
            scores: Vec<f64>,
            delta_scores: Vec<f64>,
            degrees: Vec<usize>,
        },

        // Initialization
        init: |config, graph| {
            let node_count = graph.node_count();
            PageRank {
                graph,
                scores: vec![1.0 / node_count as f64; node_count],
                delta_scores: vec![0.0; node_count],
                degrees: compute_degrees(&graph),
            }
        },

        // Main computation loop
        compute: |self| {
            for iteration in 0..self.config.max_iterations {
                // PageRank iteration logic
                self.iterate();

                if self.has_converged() {
                    break;
                }
            }

            self.scores.clone()
        },
    }
}
```

**What This Macro Generates**:

- Struct definition with fields
- Constructor implementing initialization logic
- AlgorithmSpec trait implementation
- Boilerplate for state management

### Stage 2: Register the Procedure (Registration)

This registers the algorithm in the procedure table.

**Macro Purpose**: Create ProcedureDescriptor and register it

```rust
register_procedure! {
    PageRank {
        name: "pagerank",
        category: Centrality,
        description: "Computes the PageRank score for all nodes in the graph",

        config: PageRankConfig,

        modes: [Stream, Stats, Write, Mutate],

        memory_estimate: |config: &PageRankConfig, graph: &dyn GraphStore| {
            let node_count = graph.node_count();
            // 2 f64 arrays (scores + deltas) + degree array
            MemoryEstimate {
                min: node_count * (2 * 8 + 8),
                max: node_count * (2 * 8 + 8) * 2, // double for safety
            }
        },

        validation: ValidationConfiguration::new()
            .add_before_load(RangeValidator::new("dampingFactor", 0.0, 1.0))
            .add_before_load(RangeValidator::new("maxIterations", 1.0, 1000.0))
            .add_after_load(GraphNotEmptyValidator),

        result_schema: ResultSchema::KeyValue {
            key: "nodeId",
            key_type: ValueType::Long,
            value: "score",
            value_type: ValueType::Double,
        },
    }
}
```

**What This Macro Generates**:

- ProcedureDescriptor instance
- Registration call at module init
- Type validation at compile time

## The Complete PageRank Example

### File Structure

```
src/procedure/
├── mod.rs                              # Procedure module root
├── registry.rs                         # Procedure table/registry
└── algo/
    ├── centrality/
    │   ├── mod.rs
    │   └── pagerank.rs                 # PageRank implementation
    ├── community/
    │   ├── louvain.rs
    │   └── label_propagation.rs
    └── pathfinding/
        └── shortest_path.rs
```

### src/procedure/algo/centrality/pagerank.rs

```rust
use crate::config::algo_config::PageRankConfig;
use crate::projection::codegen::procedure::AlgorithmSpec;
use crate::projection::codegen::macros::procedure::{define_algorithm, register_procedure};
use crate::types::prelude::*;

/// PageRank - Link analysis algorithm
///
/// Translated from:
/// - org.neo4j.gds.pagerank.PageRank (algorithm)
/// - org.neo4j.gds.pagerank.PageRankAlgorithmFactory (factory)
/// - org.neo4j.gds.pagerank.PageRankSpec (spec)
///
/// Java GDS Source: /home/pat/GitHub/graph-data-science/algo/src/main/java/org/neo4j/gds/pagerank/
define_algorithm! {
    PageRank {
        config: PageRankConfig,

        state: {
            graph: Arc<dyn GraphStore>,
            scores: Vec<f64>,
            delta_scores: Vec<f64>,
            out_degrees: Vec<usize>,
            damping_factor: f64,
            tolerance: f64,
        },

        init: |config, graph| {
            let node_count = graph.node_count();
            let initial_score = 1.0 / node_count as f64;

            PageRank {
                graph: graph.clone(),
                scores: vec![initial_score; node_count],
                delta_scores: vec![0.0; node_count],
                out_degrees: compute_out_degrees(&graph),
                damping_factor: config.damping_factor,
                tolerance: config.tolerance,
            }
        },

        compute: |self| {
            let node_count = self.graph.node_count();
            let base_score = (1.0 - self.damping_factor) / node_count as f64;

            for iteration in 0..self.config.max_iterations {
                // Reset deltas
                self.delta_scores.fill(0.0);

                // Distribute scores to neighbors
                for node_id in 0..node_count {
                    let score = self.scores[node_id];
                    let out_degree = self.out_degrees[node_id];

                    if out_degree > 0 {
                        let contribution = score / out_degree as f64;

                        // Iterate neighbors
                        for neighbor in self.graph.neighbors(node_id) {
                            self.delta_scores[neighbor] += contribution;
                        }
                    }
                }

                // Update scores and check convergence
                let mut max_delta = 0.0;
                for node_id in 0..node_count {
                    let new_score = base_score + self.damping_factor * self.delta_scores[node_id];
                    let delta = (new_score - self.scores[node_id]).abs();
                    max_delta = max_delta.max(delta);
                    self.scores[node_id] = new_score;
                }

                // Check convergence
                if max_delta < self.tolerance {
                    break;
                }
            }

            // Return (nodeId, score) pairs
            (0..node_count)
                .map(|i| (i as u64, self.scores[i]))
                .collect()
        },
    }
}

// Helper function
fn compute_out_degrees(graph: &Arc<dyn GraphStore>) -> Vec<usize> {
    (0..graph.node_count())
        .map(|node_id| graph.degree(node_id))
        .collect()
}

// Register with procedure table
register_procedure! {
    PageRank {
        name: "pagerank",
        category: Centrality,
        description: "Computes PageRank scores for all nodes",
        config: PageRankConfig,
        modes: [Stream, Stats, Write, Mutate],

        memory_estimate: |config, graph| {
            let nodes = graph.node_count();
            MemoryEstimate::from_bytes(nodes * (2 * 8 + 8))
        },

        validation: ValidationConfiguration::new()
            .add_before_load(RangeValidator::new("dampingFactor", 0.0, 1.0))
            .add_before_load(RangeValidator::new("tolerance", 0.0, 1.0))
            .add_after_load(GraphNotEmptyValidator),
    }
}
```

## The Macro Implementation Strategy

### Macro 1: `define_algorithm!`

**Purpose**: Generate algorithm struct + AlgorithmSpec impl

**Key Challenges**:

1. Capture closure bodies as tokens
2. Generate proper struct with lifetime parameters
3. Implement AlgorithmSpec trait correctly
4. Handle config type generically

**Implementation Approach**: Declarative macro with pattern matching

### Macro 2: `register_procedure!`

**Purpose**: Create ProcedureDescriptor + register it

**Key Challenges**:

1. Type-safe config binding
2. Memory estimator as function pointer
3. Validation builder pattern
4. Static initialization safety

**Implementation Approach**: Declarative macro + lazy_static

## The Architecture Fix (TP-008 Integration)

We need to move things to the right places:

### Current (WRONG):

```
codegen/
├── procedure/          # Has AlgorithmSpec trait
│   ├── algorithm_spec.rs
│   └── mod.rs
└── macros/
    └── procedure/      # Has unused macro placeholders
        ├── algorithm.rs
        ├── config.rs
        └── mod.rs
```

### Target (CORRECT):

```
codegen/
├── descriptors/
│   └── procedure/      # NEW: ProcedureDescriptor + Registry
│       ├── mod.rs
│       ├── descriptor.rs
│       └── registry.rs
├── runtime/
│   └── algorithm.rs    # MOVED: AlgorithmSpec trait (runtime contract)
└── macros/
    └── procedure/      # IMPROVED: Working macros
        ├── define.rs       # define_algorithm! macro
        ├── register.rs     # register_procedure! macro
        └── mod.rs

src/procedure/          # NEW: Algorithm implementations
├── mod.rs
├── registry.rs         # Re-export from codegen
└── algo/
    ├── centrality/
    │   └── pagerank.rs
    ├── community/
    └── pathfinding/
```

## Action Plan

### Phase 1: Fix Architecture (TP-008)

1. ✅ Create `codegen/descriptors/procedure/`
2. ✅ Move `AlgorithmSpec` → `codegen/runtime/algorithm.rs`
3. ✅ Create `ProcedureDescriptor` struct
4. ✅ Create procedure registry
5. ✅ Update module exports

### Phase 2: Build Macros

1. ✅ Implement `define_algorithm!` macro
2. ✅ Implement `register_procedure!` macro
3. ✅ Add tests for macro expansion
4. ✅ Document macro usage

### Phase 3: Translate PageRank

1. ✅ Find Java GDS PageRank sources
2. ✅ Translate algorithm logic
3. ✅ Use macros to generate boilerplate
4. ✅ Register in procedure table
5. ✅ Add integration tests

### Phase 4: Verify & Document

1. ✅ Test procedure lookup
2. ✅ Test all execution modes
3. ✅ Document the pattern
4. ✅ Create template for future algorithms

## Next Steps

1. Start with TP-008: Fix the architecture
2. Design the macro syntax precisely
3. Implement one macro at a time
4. Use PageRank as the proving ground
5. Create templates for other algorithms

The macros are **essential** because:

- Reduce 800-1000 lines (Java) → 200-300 lines (Rust)
- Ensure consistent registration
- Type-safe procedure table
- Make algorithm translation mechanical

Let's do this! 🚀

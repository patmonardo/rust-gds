# TP-010: Procedure Table Architecture & PageRank Blueprint

**Date**: October 16, 2025  
**Status**: Design Phase - Building the complete picture

## The Vision: A Table of Procedures

You're absolutely right - we need a **Procedure Registry/Table** where:

1. **ProcedureDescriptor** = Unifies Java GDS bloat (Spec + Proc + Facade + Params)
2. **Algorithm Implementation** = The actual algorithm code (PageRank, Louvain, etc.)
3. **Macros** = Two-stage code generation:
   - Stage 1: Register descriptor in the table
   - Stage 2: Generate execution wrappers

## The Complete Flow

```
Java GDS PageRank Sources
    â†“
Translation (with Macros)
    â†“
rust-gds PageRank Implementation
    â†“
Registration (with Macros)
    â†“
Procedure Table Entry
    â†“
GDSL Runtime Execution
```

## What Java GDS Has (The Bloated Pattern)

### Java Pattern: 5 Separate Pieces per Algorithm

For PageRank in Java GDS:

1. **PageRankConfig** (in `algo-common/`)

   - Configuration interface with annotations
   - Builder generated by annotation processor
   - Validation rules in annotations

2. **PageRank** Algorithm (in `algo/`)

   - The actual computation logic
   - Uses HugeLongArray, Partitioning, etc.

3. **PageRankAlgorithmFactory** (in `algo/`)

   - Creates PageRank instances
   - Passes config and graph

4. **PageRankSpec** (in `executor/`)

   - Implements AlgorithmSpec interface
   - Wires Config + Factory + Result handling
   - Name, category, memory estimation

5. **PageRankProc** (in `proc/`)
   - The cypher procedure entry point
   - 4 variants: Stream, Stats, Write, Mutate
   - Each is a separate class with annotations

**Total**: ~5 files, ~800-1000 lines of mostly boilerplate

### Rust Pattern: 2 Pieces + Macros

For PageRank in rust-gds:

1. **PageRank Algorithm** (in `src/procedure/algo/centrality/pagerank.rs`)

   - The actual computation logic
   - Implements `AlgorithmSpec` trait
   - Config embedded or referenced

2. **ProcedureDescriptor Registration** (via macro)
   ```rust
   register_procedure! {
       PageRank {
           name: "pagerank",
           category: "Centrality",
           config: PageRankConfig,
           modes: [Stream, Stats, Write, Mutate],
           memory_estimate: |config, graph| { ... },
           validation: |config, graph| { ... },
       }
   }
   ```

**Total**: 1 file (~200-300 lines) + macro invocation (~20 lines)

## The ProcedureDescriptor Structure

### What It Unifies

```rust
/// ProcedureDescriptor - The complete definition of an algorithm procedure
///
/// Unifies Java GDS concepts:
/// - AlgorithmSpec (what the algorithm IS)
/// - Proc (how to invoke it from cypher)
/// - Factory (how to create instances)
/// - Params/Config (what parameters it takes)
pub struct ProcedureDescriptor {
    // Identity
    pub name: &'static str,              // "pagerank"
    pub category: ProcedureCategory,      // Centrality, Community, PathFinding, etc.
    pub description: &'static str,        // Human-readable description

    // Configuration
    pub config_type: TypeId,              // TypeId::of::<PageRankConfig>()
    pub config_schema: ConfigSchema,      // JSON schema for validation
    pub default_config: fn() -> Box<dyn Any>, // Factory for defaults

    // Execution Modes
    pub supported_modes: &'static [ExecutionMode], // [Stream, Stats, Write, Mutate]

    // Validation
    pub validators: ValidationConfiguration,

    // Memory Estimation
    pub estimate_memory: MemoryEstimator,

    // Algorithm Factory
    pub create_algorithm: AlgorithmFactory,

    // Result Handling
    pub result_schema: ResultSchema,      // What the algorithm returns
}
```

### The Registry

```rust
/// Global procedure registry - lazily initialized
static PROCEDURE_REGISTRY: Lazy<RwLock<HashMap<&'static str, ProcedureDescriptor>>> =
    Lazy::new(|| RwLock::new(HashMap::new()));

/// Register a procedure (called by macro)
pub fn register_procedure(descriptor: ProcedureDescriptor) {
    let mut registry = PROCEDURE_REGISTRY.write().unwrap();
    registry.insert(descriptor.name, descriptor);
}

/// Look up a procedure by name
pub fn get_procedure(name: &str) -> Option<ProcedureDescriptor> {
    let registry = PROCEDURE_REGISTRY.read().unwrap();
    registry.get(name).cloned()
}

/// List all registered procedures
pub fn list_procedures() -> Vec<&'static str> {
    let registry = PROCEDURE_REGISTRY.read().unwrap();
    registry.keys().copied().collect()
}
```

## The Two-Stage Macro System

### Stage 1: Define the Algorithm (Translation)

This is where we need macros to help translate Java PageRank â†’ Rust PageRank.

**Macro Purpose**: Generate boilerplate for algorithm structure

```rust
define_algorithm! {
    /// PageRank algorithm implementation
    PageRank {
        // Configuration
        config: PageRankConfig,

        // State
        state: {
            graph: Arc<dyn GraphStore>,
            scores: Vec<f64>,
            delta_scores: Vec<f64>,
            degrees: Vec<usize>,
        },

        // Initialization
        init: |config, graph| {
            let node_count = graph.node_count();
            PageRank {
                graph,
                scores: vec![1.0 / node_count as f64; node_count],
                delta_scores: vec![0.0; node_count],
                degrees: compute_degrees(&graph),
            }
        },

        // Main computation loop
        compute: |self| {
            for iteration in 0..self.config.max_iterations {
                // PageRank iteration logic
                self.iterate();

                if self.has_converged() {
                    break;
                }
            }

            self.scores.clone()
        },
    }
}
```

**What This Macro Generates**:

- Struct definition with fields
- Constructor implementing initialization logic
- AlgorithmSpec trait implementation
- Boilerplate for state management

### Stage 2: Register the Procedure (Registration)

This registers the algorithm in the procedure table.

**Macro Purpose**: Create ProcedureDescriptor and register it

```rust
register_procedure! {
    PageRank {
        name: "pagerank",
        category: Centrality,
        description: "Computes the PageRank score for all nodes in the graph",

        config: PageRankConfig,

        modes: [Stream, Stats, Write, Mutate],

        memory_estimate: |config: &PageRankConfig, graph: &dyn GraphStore| {
            let node_count = graph.node_count();
            // 2 f64 arrays (scores + deltas) + degree array
            MemoryEstimate {
                min: node_count * (2 * 8 + 8),
                max: node_count * (2 * 8 + 8) * 2, // double for safety
            }
        },

        validation: ValidationConfiguration::new()
            .add_before_load(RangeValidator::new("dampingFactor", 0.0, 1.0))
            .add_before_load(RangeValidator::new("maxIterations", 1.0, 1000.0))
            .add_after_load(GraphNotEmptyValidator),

        result_schema: ResultSchema::KeyValue {
            key: "nodeId",
            key_type: ValueType::Long,
            value: "score",
            value_type: ValueType::Double,
        },
    }
}
```

**What This Macro Generates**:

- ProcedureDescriptor instance
- Registration call at module init
- Type validation at compile time

## The Complete PageRank Example

### File Structure

```
src/procedure/
â”œâ”€â”€ mod.rs                              # Procedure module root
â”œâ”€â”€ registry.rs                         # Procedure table/registry
â””â”€â”€ algo/
    â”œâ”€â”€ centrality/
    â”‚   â”œâ”€â”€ mod.rs
    â”‚   â””â”€â”€ pagerank.rs                 # PageRank implementation
    â”œâ”€â”€ community/
    â”‚   â”œâ”€â”€ louvain.rs
    â”‚   â””â”€â”€ label_propagation.rs
    â””â”€â”€ pathfinding/
        â””â”€â”€ shortest_path.rs
```

### src/procedure/algo/centrality/pagerank.rs

```rust
use crate::config::algo_config::PageRankConfig;
use crate::projection::codegen::procedure::AlgorithmSpec;
use crate::projection::codegen::macros::procedure::{define_algorithm, register_procedure};
use crate::types::prelude::*;

/// PageRank - Link analysis algorithm
///
/// Translated from:
/// - org.neo4j.gds.pagerank.PageRank (algorithm)
/// - org.neo4j.gds.pagerank.PageRankAlgorithmFactory (factory)
/// - org.neo4j.gds.pagerank.PageRankSpec (spec)
///
/// Java GDS Source: /home/pat/GitHub/graph-data-science/algo/src/main/java/org/neo4j/gds/pagerank/
define_algorithm! {
    PageRank {
        config: PageRankConfig,

        state: {
            graph: Arc<dyn GraphStore>,
            scores: Vec<f64>,
            delta_scores: Vec<f64>,
            out_degrees: Vec<usize>,
            damping_factor: f64,
            tolerance: f64,
        },

        init: |config, graph| {
            let node_count = graph.node_count();
            let initial_score = 1.0 / node_count as f64;

            PageRank {
                graph: graph.clone(),
                scores: vec![initial_score; node_count],
                delta_scores: vec![0.0; node_count],
                out_degrees: compute_out_degrees(&graph),
                damping_factor: config.damping_factor,
                tolerance: config.tolerance,
            }
        },

        compute: |self| {
            let node_count = self.graph.node_count();
            let base_score = (1.0 - self.damping_factor) / node_count as f64;

            for iteration in 0..self.config.max_iterations {
                // Reset deltas
                self.delta_scores.fill(0.0);

                // Distribute scores to neighbors
                for node_id in 0..node_count {
                    let score = self.scores[node_id];
                    let out_degree = self.out_degrees[node_id];

                    if out_degree > 0 {
                        let contribution = score / out_degree as f64;

                        // Iterate neighbors
                        for neighbor in self.graph.neighbors(node_id) {
                            self.delta_scores[neighbor] += contribution;
                        }
                    }
                }

                // Update scores and check convergence
                let mut max_delta = 0.0;
                for node_id in 0..node_count {
                    let new_score = base_score + self.damping_factor * self.delta_scores[node_id];
                    let delta = (new_score - self.scores[node_id]).abs();
                    max_delta = max_delta.max(delta);
                    self.scores[node_id] = new_score;
                }

                // Check convergence
                if max_delta < self.tolerance {
                    break;
                }
            }

            // Return (nodeId, score) pairs
            (0..node_count)
                .map(|i| (i as u64, self.scores[i]))
                .collect()
        },
    }
}

// Helper function
fn compute_out_degrees(graph: &Arc<dyn GraphStore>) -> Vec<usize> {
    (0..graph.node_count())
        .map(|node_id| graph.degree(node_id))
        .collect()
}

// Register with procedure table
register_procedure! {
    PageRank {
        name: "pagerank",
        category: Centrality,
        description: "Computes PageRank scores for all nodes",
        config: PageRankConfig,
        modes: [Stream, Stats, Write, Mutate],

        memory_estimate: |config, graph| {
            let nodes = graph.node_count();
            MemoryEstimate::from_bytes(nodes * (2 * 8 + 8))
        },

        validation: ValidationConfiguration::new()
            .add_before_load(RangeValidator::new("dampingFactor", 0.0, 1.0))
            .add_before_load(RangeValidator::new("tolerance", 0.0, 1.0))
            .add_after_load(GraphNotEmptyValidator),
    }
}
```

## The Macro Implementation Strategy

### Macro 1: `define_algorithm!`

**Purpose**: Generate algorithm struct + AlgorithmSpec impl

**Key Challenges**:

1. Capture closure bodies as tokens
2. Generate proper struct with lifetime parameters
3. Implement AlgorithmSpec trait correctly
4. Handle config type generically

**Implementation Approach**: Declarative macro with pattern matching

### Macro 2: `register_procedure!`

**Purpose**: Create ProcedureDescriptor + register it

**Key Challenges**:

1. Type-safe config binding
2. Memory estimator as function pointer
3. Validation builder pattern
4. Static initialization safety

**Implementation Approach**: Declarative macro + lazy_static

## The Architecture Fix (TP-008 Integration)

We need to move things to the right places:

### Current (WRONG):

```
codegen/
â”œâ”€â”€ procedure/          # Has AlgorithmSpec trait
â”‚   â”œâ”€â”€ algorithm_spec.rs
â”‚   â””â”€â”€ mod.rs
â””â”€â”€ macros/
    â””â”€â”€ procedure/      # Has unused macro placeholders
        â”œâ”€â”€ algorithm.rs
        â”œâ”€â”€ config.rs
        â””â”€â”€ mod.rs
```

### Target (CORRECT):

```
codegen/
â”œâ”€â”€ descriptors/
â”‚   â””â”€â”€ procedure/      # NEW: ProcedureDescriptor + Registry
â”‚       â”œâ”€â”€ mod.rs
â”‚       â”œâ”€â”€ descriptor.rs
â”‚       â””â”€â”€ registry.rs
â”œâ”€â”€ runtime/
â”‚   â””â”€â”€ algorithm.rs    # MOVED: AlgorithmSpec trait (runtime contract)
â””â”€â”€ macros/
    â””â”€â”€ procedure/      # IMPROVED: Working macros
        â”œâ”€â”€ define.rs       # define_algorithm! macro
        â”œâ”€â”€ register.rs     # register_procedure! macro
        â””â”€â”€ mod.rs

src/procedure/          # NEW: Algorithm implementations
â”œâ”€â”€ mod.rs
â”œâ”€â”€ registry.rs         # Re-export from codegen
â””â”€â”€ algo/
    â”œâ”€â”€ centrality/
    â”‚   â””â”€â”€ pagerank.rs
    â”œâ”€â”€ community/
    â””â”€â”€ pathfinding/
```

## Action Plan

### Phase 1: Fix Architecture (TP-008)

1. âœ… Create `codegen/descriptors/procedure/`
2. âœ… Move `AlgorithmSpec` â†’ `codegen/runtime/algorithm.rs`
3. âœ… Create `ProcedureDescriptor` struct
4. âœ… Create procedure registry
5. âœ… Update module exports

### Phase 2: Build Macros

1. âœ… Implement `define_algorithm!` macro
2. âœ… Implement `register_procedure!` macro
3. âœ… Add tests for macro expansion
4. âœ… Document macro usage

### Phase 3: Translate PageRank

1. âœ… Find Java GDS PageRank sources
2. âœ… Translate algorithm logic
3. âœ… Use macros to generate boilerplate
4. âœ… Register in procedure table
5. âœ… Add integration tests

### Phase 4: Verify & Document

1. âœ… Test procedure lookup
2. âœ… Test all execution modes
3. âœ… Document the pattern
4. âœ… Create template for future algorithms

## Next Steps

1. Start with TP-008: Fix the architecture
2. Design the macro syntax precisely
3. Implement one macro at a time
4. Use PageRank as the proving ground
5. Create templates for other algorithms

The macros are **essential** because:

- Reduce 800-1000 lines (Java) â†’ 200-300 lines (Rust)
- Ensure consistent registration
- Type-safe procedure table
- Make algorithm translation mechanical

Let's do this! ðŸš€

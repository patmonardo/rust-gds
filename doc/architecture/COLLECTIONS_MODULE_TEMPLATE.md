# Collections Module Template: Incremental Adoption Design

**Date**: October 15, 2025  
**Status**: ðŸ—ï¸ **Module Design** - Collections Reorganization  
**Context**: Level 1 Upgrade - Collections Architecture

---

## ðŸŽ¯ Executive Summary

Design a new Collections module with:
1. **Barrel export design** for clean API
2. **Three top-level folders**: `huge`, `vec`, `arrow`
3. **Incremental adoption** strategy
4. **Collections macro system** for code generation
5. **Backward compatibility** with existing HugeArray

---

## Part 1: New Collections Module Structure

### **Directory Layout**

```
gds/src/collections/
â”œâ”€â”€ mod.rs                    # Barrel exports
â”œâ”€â”€ traits/
â”‚   â”œâ”€â”€ mod.rs               # Collections trait definitions
â”‚   â”œâ”€â”€ collections.rs       # Main Collections trait
â”‚   â”œâ”€â”€ adapter.rs           # PropertyValues adapter trait
â”‚   â””â”€â”€ factory.rs           # Collections factory trait
â”œâ”€â”€ huge/                    # HugeArray Collections
â”‚   â”œâ”€â”€ mod.rs               # Huge barrel exports
â”‚   â”œâ”€â”€ huge_array.rs        # Main HugeArray enum
â”‚   â”œâ”€â”€ huge_int_array.rs    # Generated by macro
â”‚   â”œâ”€â”€ huge_long_array.rs   # Generated by macro
â”‚   â”œâ”€â”€ huge_double_array.rs # Generated by macro
â”‚   â””â”€â”€ ...                  # Other primitive types
â”œâ”€â”€ vec/                     # Vec Collections
â”‚   â”œâ”€â”€ mod.rs               # Vec barrel exports
â”‚   â”œâ”€â”€ enhanced_vec.rs      # Enhanced Vec implementation
â”‚   â”œâ”€â”€ vec_int.rs           # Generated by macro
â”‚   â”œâ”€â”€ vec_long.rs          # Generated by macro
â”‚   â””â”€â”€ vec_double.rs        # Generated by macro
â”œâ”€â”€ arrow/                   # Arrow Collections
â”‚   â”œâ”€â”€ mod.rs               # Arrow barrel exports
â”‚   â”œâ”€â”€ arrow_array.rs       # Arrow array wrapper
â”‚   â”œâ”€â”€ arrow_int.rs         # Generated by macro
â”‚   â”œâ”€â”€ arrow_long.rs        # Generated by macro
â”‚   â””â”€â”€ arrow_double.rs      # Generated by macro
â”œâ”€â”€ adapter/                 # Universal Adapter
â”‚   â”œâ”€â”€ mod.rs               # Adapter barrel exports
â”‚   â”œâ”€â”€ universal.rs         # UniversalPropertyValues
â”‚   â”œâ”€â”€ factory.rs           # Collections factory
â”‚   â””â”€â”€ macros.rs            # Adapter generation macros
â””â”€â”€ macros/                  # Collections Macros
    â”œâ”€â”€ mod.rs               # Macro barrel exports
    â”œâ”€â”€ collections.rs       # Main Collections macro
    â”œâ”€â”€ huge.rs              # HugeArray generation macro
    â”œâ”€â”€ vec.rs               # Vec generation macro
    â””â”€â”€ arrow.rs              # Arrow generation macro
```

---

## Part 2: Barrel Export Design

### **Main Collections Module (`collections/mod.rs`)**

```rust
//! Collections: Unified Data Structures for Graph Data Science
//!
//! This module provides a unified Collections API across three backends:
//! - **Huge**: Paged arrays for billions of elements
//! - **Vec**: Enhanced standard library vectors
//! - **Arrow**: Apache Arrow columnar arrays
//!
//! ## Architecture
//!
//! ```text
//! Application Layer (PropertyValues)
//!         â†“
//! Adapter Layer (UniversalPropertyValues)
//!         â†“
//! Collections Layer (Huge/Vec/Arrow)
//! ```

// Core traits
pub mod traits;
pub use traits::{
    Collections, PropertyValuesAdapter, CollectionsFactory,
};

// Collections implementations
pub mod huge;
pub mod vec;
pub mod arrow;

// Universal adapter
pub mod adapter;

// Code generation macros
pub mod macros;

// Re-export commonly used types
pub use huge::{HugeIntArray, HugeLongArray, HugeDoubleArray};
pub use vec::{EnhancedVec, VecInt, VecLong, VecDouble};
pub use arrow::{ArrowInt, ArrowLong, ArrowDouble};
pub use adapter::{UniversalPropertyValues, CollectionsFactory};

// Re-export macros for external use
pub use macros::{
    collections_impl, huge_collections, vec_collections, arrow_collections,
};

// Backend selection
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CollectionsBackend {
    Huge,   // Paged arrays
    Vec,    // Enhanced vectors
    Arrow,  // Apache Arrow
}

impl Default for CollectionsBackend {
    fn default() -> Self {
        Self::Vec
    }
}
```

### **Huge Collections Barrel (`collections/huge/mod.rs`)**

```rust
//! Huge Collections: Paged Arrays for Billions of Elements
//!
//! Provides paged array implementations that can handle massive datasets
//! by splitting data across multiple pages with automatic single-page
//! vs multi-page selection.

// Re-export existing HugeArray types (backward compatibility)
pub use crate::collections::huge_array::{
    HugeIntArray, HugeLongArray, HugeDoubleArray, HugeFloatArray,
    HugeByteArray, HugeShortArray, HugeBooleanArray, HugeCharArray,
    HugeObjectArray,
};

// Re-export Collections trait implementations
pub use crate::collections::traits::Collections;

// Implement Collections for existing HugeArray types
impl Collections<i32> for HugeIntArray { /* ... */ }
impl Collections<i64> for HugeLongArray { /* ... */ }
impl Collections<f64> for HugeDoubleArray { /* ... */ }
// ... other implementations

// Huge-specific utilities
pub mod utils {
    pub use crate::collections::huge_array::PageUtil;
    pub use crate::collections::huge_array::ArrayUtil;
}

// Huge-specific macros
pub use crate::collections::macros::huge_collections;
```

### **Vec Collections Barrel (`collections/vec/mod.rs`)**

```rust
//! Vec Collections: Enhanced Standard Library Vectors
//!
//! Provides enhanced Vec implementations with Collections API,
//! including aggregation methods, nullability support, and
//! Arrow compatibility.

use crate::collections::traits::Collections;

// Enhanced Vec implementation
pub mod enhanced_vec;
pub use enhanced_vec::EnhancedVec;

// Generated Vec types (by macro)
pub mod vec_int;
pub mod vec_long;
pub mod vec_double;
pub mod vec_float;
pub mod vec_byte;
pub mod vec_short;
pub mod vec_boolean;
pub mod vec_char;

// Re-export generated types
pub use vec_int::VecInt;
pub use vec_long::VecLong;
pub use vec_double::VecDouble;
pub use vec_float::VecFloat;
pub use vec_byte::VecByte;
pub use vec_short::VecShort;
pub use vec_boolean::VecBoolean;
pub use vec_char::VecChar;

// Implement Collections for Vec types
impl<T> Collections<T> for Vec<T> where T: Clone + Default + Ord + Sum {
    // Implementation...
}

impl Collections<i32> for VecInt { /* ... */ }
impl Collections<i64> for VecLong { /* ... */ }
impl Collections<f64> for VecDouble { /* ... */ }
// ... other implementations

// Vec-specific utilities
pub mod utils {
    // Vec-specific helper functions
}

// Vec-specific macros
pub use crate::collections::macros::vec_collections;
```

### **Arrow Collections Barrel (`collections/arrow/mod.rs`)**

```rust
//! Arrow Collections: Apache Arrow Columnar Arrays
//!
//! Provides Arrow array implementations with Collections API,
//! including compute kernels, nullability, and file format support.

use crate::collections::traits::Collections;

// Arrow wrapper implementation
pub mod arrow_array;
pub use arrow_array::ArrowArray;

// Generated Arrow types (by macro)
pub mod arrow_int;
pub mod arrow_long;
pub mod arrow_double;
pub mod arrow_float;
pub mod arrow_byte;
pub mod arrow_short;
pub mod arrow_boolean;
pub mod arrow_char;

// Re-export generated types
pub use arrow_int::ArrowInt;
pub use arrow_long::ArrowLong;
pub use arrow_double::ArrowDouble;
pub use arrow_float::ArrowFloat;
pub use arrow_byte::ArrowByte;
pub use arrow_short::ArrowShort;
pub use arrow_boolean::ArrowBoolean;
pub use arrow_char::ArrowChar;

// Implement Collections for Arrow types
impl Collections<i32> for ArrowInt { /* ... */ }
impl Collections<i64> for ArrowLong { /* ... */ }
impl Collections<f64> for ArrowDouble { /* ... */ }
// ... other implementations

// Arrow-specific utilities
pub mod utils {
    // Arrow-specific helper functions
    pub use arrow::compute::*;
    pub use arrow::array::*;
}

// Arrow-specific macros
pub use crate::collections::macros::arrow_collections;
```

---

## Part 3: Collections Macro System

### **Main Collections Macro (`collections/macros/collections.rs`)**

```rust
//! Collections Macro: Generate Collections implementations
//!
//! This macro generates complete Collections implementations for any type,
//! including the Collections trait, PropertyValues adapter, and factory methods.

#[macro_export]
macro_rules! collections_impl {
    (
        $type_name:ident,           // e.g., VecInt, HugeIntArray, ArrowInt
        $element_type:ty,           // e.g., i32, i64, f64
        $value_type:expr,           // e.g., ValueType::Int, ValueType::Long
        $default_value:expr,        // e.g., 0i32, 0i64, 0.0f64
        $backend:expr,              // e.g., CollectionsBackend::Vec
        $doc_desc:expr              // Documentation description
    ) => {
        use crate::collections::traits::{Collections, PropertyValuesAdapter};
        use crate::collections::adapter::UniversalPropertyValues;
        use crate::types::ValueType;
        use crate::types::properties::property_values::{PropertyValues, PropertyValuesResult};

        #[doc = $doc_desc]
        pub struct $type_name {
            data: $element_type,
            // Additional fields as needed
        }

        impl $type_name {
            /// Creates a new instance
            pub fn new() -> Self {
                Self {
                    data: $default_value,
                }
            }

            /// Creates from Vec
            pub fn from_vec(values: Vec<$element_type>) -> Self {
                // Implementation depends on backend
            }

            /// Converts to Vec
            pub fn to_vec(self) -> Vec<$element_type> {
                // Implementation depends on backend
            }
        }

        // Implement Collections trait
        impl Collections<$element_type> for $type_name {
            fn get(&self, index: usize) -> Option<$element_type> {
                // Backend-specific implementation
            }

            fn set(&mut self, index: usize, value: $element_type) {
                // Backend-specific implementation
            }

            fn len(&self) -> usize {
                // Backend-specific implementation
            }

            fn is_empty(&self) -> bool {
                self.len() == 0
            }

            fn sum(&self) -> Option<$element_type> where $element_type: Sum {
                // Backend-specific implementation
            }

            fn min(&self) -> Option<$element_type> where $element_type: Ord {
                // Backend-specific implementation
            }

            fn max(&self) -> Option<$element_type> where $element_type: Ord {
                // Backend-specific implementation
            }

            fn mean(&self) -> Option<f64> where $element_type: Into<f64> {
                // Backend-specific implementation
            }

            fn binary_search(&self, key: &$element_type) -> Result<usize, usize> 
            where $element_type: Ord {
                // Backend-specific implementation
            }

            fn sort(&mut self) where $element_type: Ord {
                // Backend-specific implementation
            }

            fn to_vec(self) -> Vec<$element_type> {
                self.to_vec()
            }

            fn as_slice(&self) -> &[$element_type] {
                // Backend-specific implementation
            }

            fn is_null(&self, index: usize) -> bool {
                // Backend-specific implementation
            }

            fn null_count(&self) -> usize {
                // Backend-specific implementation
            }
        }

        // Implement PropertyValuesAdapter
        impl PropertyValuesAdapter<$element_type> for $type_name {
            fn value_type(&self) -> ValueType {
                $value_type
            }

            fn default_value(&self) -> $element_type {
                $default_value
            }

            fn backend(&self) -> CollectionsBackend {
                $backend
            }
        }

        // Factory method
        impl $type_name {
            pub fn create_property_values(
                values: Vec<$element_type>,
                element_count: usize,
            ) -> UniversalPropertyValues<$element_type, Self> {
                UniversalPropertyValues::new(
                    Self::from_vec(values),
                    $value_type,
                    $default_value,
                )
            }
        }
    };
}
```

### **Backend-Specific Macros**

#### **Vec Collections Macro (`collections/macros/vec.rs`)**

```rust
//! Vec Collections Macro: Generate Vec-based Collections

#[macro_export]
macro_rules! vec_collections {
    (
        $type_name:ident,           // e.g., VecInt
        $element_type:ty,           // e.g., i32
        $value_type:expr,           // e.g., ValueType::Int
        $default_value:expr,        // e.g., 0i32
        $doc_desc:expr              // Documentation
    ) => {
        collections_impl! {
            $type_name,
            $element_type,
            $value_type,
            $default_value,
            CollectionsBackend::Vec,
            $doc_desc
        }

        // Vec-specific implementation
        impl $type_name {
            pub fn new() -> Self {
                Self {
                    data: Vec::new(),
                }
            }

            pub fn with_capacity(capacity: usize) -> Self {
                Self {
                    data: Vec::with_capacity(capacity),
                }
            }

            pub fn push(&mut self, value: $element_type) {
                self.data.push(value);
            }

            pub fn pop(&mut self) -> Option<$element_type> {
                self.data.pop()
            }
        }

        impl Collections<$element_type> for $type_name {
            fn get(&self, index: usize) -> Option<$element_type> {
                self.data.get(index).cloned()
            }

            fn set(&mut self, index: usize, value: $element_type) {
                if index < self.data.len() {
                    self.data[index] = value;
                } else {
                    self.data.resize(index + 1, $default_value);
                    self.data[index] = value;
                }
            }

            fn len(&self) -> usize {
                self.data.len()
            }

            fn sum(&self) -> Option<$element_type> where $element_type: Sum {
                Some(self.data.iter().cloned().sum())
            }

            fn mean(&self) -> Option<f64> where $element_type: Into<f64> {
                if self.data.is_empty() {
                    None
                } else {
                    Some(
                        self.data.iter()
                            .map(|&x| x.into())
                            .sum::<f64>() / self.data.len() as f64
                    )
                }
            }

            fn as_slice(&self) -> &[$element_type] {
                &self.data
            }

            fn is_null(&self, _index: usize) -> bool { false }
            fn null_count(&self) -> usize { 0 }
        }
    };
}
```

#### **Huge Collections Macro (`collections/macros/huge.rs`)**

```rust
//! Huge Collections Macro: Generate HugeArray-based Collections

#[macro_export]
macro_rules! huge_collections {
    (
        $type_name:ident,           // e.g., HugeIntArray
        $element_type:ty,           // e.g., i32
        $value_type:expr,           // e.g., ValueType::Int
        $default_value:expr,        // e.g., 0i32
        $doc_desc:expr              // Documentation
    ) => {
        collections_impl! {
            $type_name,
            $element_type,
            $value_type,
            $default_value,
            CollectionsBackend::Huge,
            $doc_desc
        }

        // Huge-specific implementation
        impl Collections<$element_type> for $type_name {
            fn get(&self, index: usize) -> Option<$element_type> {
                if index < self.size() {
                    Some(self.get(index))
                } else {
                    None
                }
            }

            fn set(&mut self, index: usize, value: $element_type) {
                if index < self.size() {
                    self.set(index, value);
                }
            }

            fn len(&self) -> usize {
                self.size()
            }

            fn sum(&self) -> Option<$element_type> where $element_type: Sum {
                Some(self.iter().sum())
            }

            fn mean(&self) -> Option<f64> where $element_type: Into<f64> {
                if self.size() == 0 {
                    None
                } else {
                    Some(
                        self.iter()
                            .map(|x| x.into())
                            .sum::<f64>() / self.size() as f64
                    )
                }
            }

            fn as_slice(&self) -> &[$element_type] {
                // HugeArray doesn't support slices, return empty
                &[]
            }

            fn is_null(&self, _index: usize) -> bool { false }
            fn null_count(&self) -> usize { 0 }
        }
    };
}
```

---

## Part 4: Incremental Adoption Strategy

### **Phase 1: Create New Structure (Day 1)**

1. **Create new Collections module** structure
2. **Move existing HugeArray** to `collections/huge/`
3. **Implement Collections trait** for existing HugeArray
4. **Update imports** to use new barrel exports
5. **Ensure backward compatibility**

### **Phase 2: Implement Vec Collections (Day 2)**

1. **Create Vec Collections** using `vec_collections!` macro
2. **Implement EnhancedVec** with aggregation methods
3. **Add Vec-specific utilities**
4. **Test Vec Collections** implementation

### **Phase 3: Implement Arrow Collections (Day 3)**

1. **Create Arrow Collections** using `arrow_collections!` macro
2. **Implement Arrow wrapper** with compute kernels
3. **Add Arrow-specific utilities**
4. **Test Arrow Collections** implementation

### **Phase 4: Universal Adapter (Day 4)**

1. **Create UniversalPropertyValues** adapter
2. **Implement Collections factory**
3. **Migrate existing PropertyValues** to use adapter
4. **Performance testing** and optimization

---

## Part 5: Migration Example

### **Before: Separate Implementations**

```rust
// Old structure
gds/src/collections/huge_array/
â”œâ”€â”€ mod.rs
â”œâ”€â”€ huge_int_array.rs
â”œâ”€â”€ huge_long_array.rs
â””â”€â”€ huge_double_array.rs

// Old usage
use crate::collections::huge_array::HugeIntArray;
```

### **After: Unified Collections**

```rust
// New structure
gds/src/collections/
â”œâ”€â”€ mod.rs                    # Barrel exports
â”œâ”€â”€ huge/mod.rs               # Huge barrel
â”œâ”€â”€ vec/mod.rs                # Vec barrel
â”œâ”€â”€ arrow/mod.rs              # Arrow barrel
â””â”€â”€ macros/collections.rs     # Macro system

// New usage
use crate::collections::{HugeIntArray, VecInt, ArrowInt};
use crate::collections::Collections;
use crate::collections::UniversalPropertyValues;

// All implement same interface
let huge: HugeIntArray = HugeIntArray::new(1000);
let vec: VecInt = VecInt::new();
let arrow: ArrowInt = ArrowInt::new();

// Same API for all
let sum1 = huge.sum();
let sum2 = vec.sum();
let sum3 = arrow.sum();
```

---

## Part 6: Implementation Checklist

### **Immediate Actions**

- [ ] Create `gds/src/collections/` directory structure
- [ ] Move existing HugeArray to `collections/huge/`
- [ ] Create barrel exports in each module
- [ ] Implement Collections trait for HugeArray
- [ ] Update imports throughout codebase

### **Next Steps**

- [ ] Create `vec_collections!` macro
- [ ] Implement Vec Collections types
- [ ] Create `arrow_collections!` macro
- [ ] Implement Arrow Collections types
- [ ] Create UniversalPropertyValues adapter
- [ ] Migrate PropertyValues to use adapter

---

## Part 7: Conclusion

### **Key Benefits**

1. **Clean Architecture**: Three-tier system with clear separation
2. **Incremental Adoption**: Can implement one backend at a time
3. **Backward Compatibility**: Existing HugeArray continues to work
4. **Unified API**: All Collections implement same interface
5. **Code Generation**: Macros reduce boilerplate significantly

### **Next Steps**

1. **Create Collections module** structure
2. **Move HugeArray** to new location
3. **Implement Collections trait** for HugeArray
4. **Create Vec Collections** using macros
5. **Add Arrow Collections** support

---

**Status**: âœ… **Module Template Complete**  
**Next**: Implement Collections module structure and migrate HugeArray

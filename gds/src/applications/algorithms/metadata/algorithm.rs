/// This is a fundamental need: a stable, unique identifier to key things to an algorithm.
/// Enums are great because we can switch on them and get completion - no forgetting to map one of them.
/// I have one central authority. But I need to apply the mapping in different contexts,
/// sometimes as part of request processing, sometimes outside request scope. So switch statements in different places,
/// and the safety that I won't forget to map a key.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum Algorithm {
    AllShortestPaths,
    ApproximateMaximumKCut,
    ArticleRank,
    ArticulationPoints,
    AStar,
    BellmanFord,
    BetaClosenessCentrality,
    BetweennessCentrality,
    BFS,
    Bridges,
    CELF,
    ClosenessCentrality,
    CollapsePath,
    Conductance,
    DegreeCentrality,
    DeltaStepping,
    DFS,
    Dijkstra,
    EigenVector,
    FastRP,
    FilteredKNN,
    FilteredNodeSimilarity,
    GraphSage,
    GraphSageTrain,
    HITS,
    HarmonicCentrality,
    HashGNN,
    IndexInverse,
    K1Coloring,
    KCore,
    KGE,
    KMeans,
    KNN,
    KSpanningTree,
    LabelPropagation,
    LCC,
    Leiden,
    Louvain,
    LongestPath,
    Modularity,
    ModularityOptimization,
    NodeSimilarity,
    Node2Vec,
    PageRank,
    PCST,
    RandomWalk,
    ScaleProperties,
    SCC,
    SingleSourceDijkstra,
    SLLPA,
    SpanningTree,
    SplitRelationships,
    SteinerTree,
    TopologicalSort,
    ToUndirected,
    TriangleCount,
    Triangles,
    WCC,
    Yens,
}

impl Algorithm {
    /// Returns the string representation of the algorithm for display purposes.
    pub fn as_string(&self) -> &'static str {
        match self {
            Algorithm::AllShortestPaths => "AllShortestPaths",
            Algorithm::ApproximateMaximumKCut => "ApproximateMaximumKCut",
            Algorithm::ArticleRank => "ArticleRank",
            Algorithm::ArticulationPoints => "ArticulationPoints",
            Algorithm::AStar => "AStar",
            Algorithm::BellmanFord => "BellmanFord",
            Algorithm::BetaClosenessCentrality => "BetaClosenessCentrality",
            Algorithm::BetweennessCentrality => "BetweennessCentrality",
            Algorithm::BFS => "BFS",
            Algorithm::Bridges => "Bridges",
            Algorithm::CELF => "CELF",
            Algorithm::ClosenessCentrality => "ClosenessCentrality",
            Algorithm::CollapsePath => "CollapsePath",
            Algorithm::Conductance => "Conductance",
            Algorithm::DegreeCentrality => "DegreeCentrality",
            Algorithm::DeltaStepping => "DeltaStepping",
            Algorithm::DFS => "DFS",
            Algorithm::Dijkstra => "Dijkstra",
            Algorithm::EigenVector => "EigenVector",
            Algorithm::FastRP => "FastRP",
            Algorithm::FilteredKNN => "FilteredKNN",
            Algorithm::FilteredNodeSimilarity => "FilteredNodeSimilarity",
            Algorithm::GraphSage => "GraphSage",
            Algorithm::GraphSageTrain => "GraphSageTrain",
            Algorithm::HITS => "HITS",
            Algorithm::HarmonicCentrality => "HarmonicCentrality",
            Algorithm::HashGNN => "HashGNN",
            Algorithm::IndexInverse => "IndexInverse",
            Algorithm::K1Coloring => "K1Coloring",
            Algorithm::KCore => "KCore",
            Algorithm::KGE => "KGE",
            Algorithm::KMeans => "KMeans",
            Algorithm::KNN => "KNN",
            Algorithm::KSpanningTree => "KSpanningTree",
            Algorithm::LabelPropagation => "LabelPropagation",
            Algorithm::LCC => "LCC",
            Algorithm::Leiden => "Leiden",
            Algorithm::Louvain => "Louvain",
            Algorithm::LongestPath => "LongestPath",
            Algorithm::Modularity => "Modularity",
            Algorithm::ModularityOptimization => "ModularityOptimization",
            Algorithm::NodeSimilarity => "NodeSimilarity",
            Algorithm::Node2Vec => "Node2Vec",
            Algorithm::PageRank => "PageRank",
            Algorithm::PCST => "PCST",
            Algorithm::RandomWalk => "RandomWalk",
            Algorithm::ScaleProperties => "ScaleProperties",
            Algorithm::SCC => "SCC",
            Algorithm::SingleSourceDijkstra => "SingleSourceDijkstra",
            Algorithm::SLLPA => "SLLPA",
            Algorithm::SpanningTree => "SpanningTree",
            Algorithm::SplitRelationships => "SplitRelationships",
            Algorithm::SteinerTree => "SteinerTree",
            Algorithm::TopologicalSort => "TopologicalSort",
            Algorithm::ToUndirected => "ToUndirected",
            Algorithm::TriangleCount => "TriangleCount",
            Algorithm::Triangles => "Triangles",
            Algorithm::WCC => "WCC",
            Algorithm::Yens => "Yens",
        }
    }
}

impl std::fmt::Display for Algorithm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_string())
    }
}
